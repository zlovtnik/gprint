-- Migration: 006_dynamic_crud_v2.sql
-- Fully Dynamic PL/SQL Package for CRUD Operations
-- Uses Oracle data dictionary for all validations - no hardcoded tables/columns

-- ============================================================================
-- CLEANUP: Drop existing objects in reverse dependency order
-- ============================================================================

-- Drop stored procedures first (they depend on types and package)
BEGIN EXECUTE IMMEDIATE 'DROP PROCEDURE sp_generic_insert'; EXCEPTION WHEN OTHERS THEN NULL; END;
/
BEGIN EXECUTE IMMEDIATE 'DROP PROCEDURE sp_generic_update'; EXCEPTION WHEN OTHERS THEN NULL; END;
/
BEGIN EXECUTE IMMEDIATE 'DROP PROCEDURE sp_generic_delete'; EXCEPTION WHEN OTHERS THEN NULL; END;
/
BEGIN EXECUTE IMMEDIATE 'DROP PROCEDURE sp_generic_get'; EXCEPTION WHEN OTHERS THEN NULL; END;
/
BEGIN EXECUTE IMMEDIATE 'DROP PROCEDURE sp_generic_list'; EXCEPTION WHEN OTHERS THEN NULL; END;
/
BEGIN EXECUTE IMMEDIATE 'DROP PROCEDURE sp_generic_aggregate'; EXCEPTION WHEN OTHERS THEN NULL; END;
/

-- Drop package (depends on types)
BEGIN EXECUTE IMMEDIATE 'DROP PACKAGE pkg_crud'; EXCEPTION WHEN OTHERS THEN NULL; END;
/

-- Drop collection types first (they depend on object types)
BEGIN EXECUTE IMMEDIATE 'DROP TYPE t_column_values FORCE'; EXCEPTION WHEN OTHERS THEN NULL; END;
/
BEGIN EXECUTE IMMEDIATE 'DROP TYPE t_filter_conditions FORCE'; EXCEPTION WHEN OTHERS THEN NULL; END;
/
BEGIN EXECUTE IMMEDIATE 'DROP TYPE t_sort_specs FORCE'; EXCEPTION WHEN OTHERS THEN NULL; END;
/
BEGIN EXECUTE IMMEDIATE 'DROP TYPE t_column_metas FORCE'; EXCEPTION WHEN OTHERS THEN NULL; END;
/

-- Drop object types
BEGIN EXECUTE IMMEDIATE 'DROP TYPE t_column_value FORCE'; EXCEPTION WHEN OTHERS THEN NULL; END;
/
BEGIN EXECUTE IMMEDIATE 'DROP TYPE t_filter_condition FORCE'; EXCEPTION WHEN OTHERS THEN NULL; END;
/
BEGIN EXECUTE IMMEDIATE 'DROP TYPE t_sort_spec FORCE'; EXCEPTION WHEN OTHERS THEN NULL; END;
/
BEGIN EXECUTE IMMEDIATE 'DROP TYPE t_crud_result FORCE'; EXCEPTION WHEN OTHERS THEN NULL; END;
/
BEGIN EXECUTE IMMEDIATE 'DROP TYPE t_column_meta FORCE'; EXCEPTION WHEN OTHERS THEN NULL; END;
/

-- ============================================================================
-- CONFIGURATION TABLE - Dynamic table/column allowlist
-- ============================================================================

-- Table to control which tables are allowed for dynamic operations
BEGIN
    EXECUTE IMMEDIATE 'CREATE TABLE crud_allowed_tables (
        id            NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        table_name    VARCHAR2(128) NOT NULL,
        schema_name   VARCHAR2(128) DEFAULT USER,
        allow_insert  NUMBER(1) DEFAULT 1,
        allow_update  NUMBER(1) DEFAULT 1,
        allow_delete  NUMBER(1) DEFAULT 1,
        allow_select  NUMBER(1) DEFAULT 1,
        require_tenant NUMBER(1) DEFAULT 1,
        id_column     VARCHAR2(128) DEFAULT ''ID'',
        tenant_column VARCHAR2(128) DEFAULT ''TENANT_ID'',
        audit_columns VARCHAR2(500) DEFAULT ''CREATED_AT,UPDATED_AT,CREATED_BY,UPDATED_BY'',
        created_at    TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        CONSTRAINT uk_crud_allowed_tables UNIQUE (schema_name, table_name)
    )';
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE != -955 THEN RAISE; END IF; -- Table already exists
END;
/

-- Table to define allowed aggregate expressions per table
-- SECURITY WARNING: The expression column is concatenated into dynamic SQL.
-- Only trusted admin users should have INSERT/UPDATE permissions on this table.
-- Expressions are validated against a whitelist pattern in register_aggregate.
BEGIN
    EXECUTE IMMEDIATE 'CREATE TABLE crud_allowed_aggregates (
        id              NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        parent_table    VARCHAR2(128) NOT NULL,
        child_table     VARCHAR2(128) NOT NULL,
        agg_column      VARCHAR2(128) NOT NULL,
        fk_column       VARCHAR2(128) NOT NULL,
        expression      VARCHAR2(500) NOT NULL,
        description     VARCHAR2(500),
        created_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        CONSTRAINT uk_crud_aggregates UNIQUE (parent_table, child_table, agg_column)
    )';
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE != -955 THEN RAISE; END IF; -- Table already exists
END;
/

-- Insert default allowed tables (ignore duplicates)
BEGIN INSERT INTO crud_allowed_tables (table_name, require_tenant) VALUES ('CONTRACTS', 1); EXCEPTION WHEN OTHERS THEN NULL; END;
/
BEGIN INSERT INTO crud_allowed_tables (table_name, require_tenant) VALUES ('CONTRACT_ITEMS', 1); EXCEPTION WHEN OTHERS THEN NULL; END;
/
BEGIN INSERT INTO crud_allowed_tables (table_name, require_tenant) VALUES ('CUSTOMERS', 1); EXCEPTION WHEN OTHERS THEN NULL; END;
/
BEGIN INSERT INTO crud_allowed_tables (table_name, require_tenant) VALUES ('SERVICES', 1); EXCEPTION WHEN OTHERS THEN NULL; END;
/
BEGIN INSERT INTO crud_allowed_tables (table_name, require_tenant) VALUES ('CONTRACT_HISTORY', 1); EXCEPTION WHEN OTHERS THEN NULL; END;
/
BEGIN INSERT INTO crud_allowed_tables (table_name, require_tenant) VALUES ('CONTRACT_PRINT_JOBS', 1); EXCEPTION WHEN OTHERS THEN NULL; END;
/
BEGIN INSERT INTO crud_allowed_tables (table_name, require_tenant) VALUES ('CONTRACT_TEMPLATES', 1); EXCEPTION WHEN OTHERS THEN NULL; END;
/
BEGIN INSERT INTO crud_allowed_tables (table_name, require_tenant) VALUES ('GENERATED_CONTRACTS', 1); EXCEPTION WHEN OTHERS THEN NULL; END;
/

-- Insert default allowed aggregates (ignore duplicates)
BEGIN
    INSERT INTO crud_allowed_aggregates (parent_table, child_table, agg_column, fk_column, expression, description)
    VALUES ('CONTRACTS', 'CONTRACT_ITEMS', 'TOTAL_VALUE', 'CONTRACT_ID', 
            'SUM(quantity * unit_price * (1 - NVL(discount_pct,0)/100))', 
            'Calculate contract total from line items');
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

-- Error logging table for persistent diagnostics
BEGIN
    EXECUTE IMMEDIATE 'CREATE TABLE error_log (
        id          NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        log_time    TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        context     VARCHAR2(500),
        message     VARCHAR2(4000),
        severity    VARCHAR2(20) DEFAULT ''ERROR''
    )';
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE != -955 THEN RAISE; END IF; -- Table already exists
END;
/

-- ============================================================================
-- ENHANCED TYPE SPECIFICATIONS
-- ============================================================================

-- Column metadata from data dictionary
CREATE OR REPLACE TYPE t_column_meta AS OBJECT (
    column_name   VARCHAR2(128),
    data_type     VARCHAR2(128),
    data_length   NUMBER,
    data_precision NUMBER,
    data_scale    NUMBER,
    nullable      VARCHAR2(1),
    
    MEMBER FUNCTION format_value(p_value VARCHAR2) RETURN VARCHAR2,
    MEMBER FUNCTION get_bind_expression(p_bind_idx NUMBER) RETURN VARCHAR2
);
/

CREATE OR REPLACE TYPE BODY t_column_meta AS
    -- Format value based on data type for SQL
    MEMBER FUNCTION format_value(p_value VARCHAR2) RETURN VARCHAR2 IS
    BEGIN
        IF p_value IS NULL THEN
            RETURN 'NULL';
        END IF;
        
        CASE 
            WHEN SELF.data_type IN ('NUMBER', 'INTEGER', 'FLOAT', 'BINARY_FLOAT', 'BINARY_DOUBLE') THEN
                RETURN p_value;
            WHEN SELF.data_type LIKE '%CHAR%' OR SELF.data_type = 'CLOB' THEN
                RETURN '''' || REPLACE(p_value, '''', '''''') || '''';
            WHEN SELF.data_type = 'DATE' THEN
                RETURN 'TO_DATE(''' || p_value || ''', ''YYYY-MM-DD'')';
            WHEN SELF.data_type LIKE 'TIMESTAMP%' THEN
                RETURN 'TO_TIMESTAMP(''' || p_value || ''', ''YYYY-MM-DD"T"HH24:MI:SS.FF'')';
            ELSE
                RETURN '''' || REPLACE(p_value, '''', '''''') || '''';
        END CASE;
    END format_value;
    
    -- Get bind variable expression with type conversion
    MEMBER FUNCTION get_bind_expression(p_bind_idx NUMBER) RETURN VARCHAR2 IS
    BEGIN
        CASE 
            WHEN SELF.data_type IN ('NUMBER', 'INTEGER', 'FLOAT', 'BINARY_FLOAT', 'BINARY_DOUBLE') THEN
                RETURN 'TO_NUMBER(:' || p_bind_idx || ')';
            WHEN SELF.data_type = 'DATE' THEN
                RETURN 'TO_DATE(:' || p_bind_idx || ', ''YYYY-MM-DD'')';
            WHEN SELF.data_type LIKE 'TIMESTAMP%' THEN
                RETURN 'TO_TIMESTAMP(:' || p_bind_idx || ', ''YYYY-MM-DD"T"HH24:MI:SS'')';
            ELSE
                RETURN ':' || p_bind_idx;
        END CASE;
    END get_bind_expression;
END;
/

-- Collection of column metadata
CREATE OR REPLACE TYPE t_column_metas AS TABLE OF t_column_meta;
/

-- ============================================================================
-- ADDITIONAL TYPES FOR CRUD OPERATIONS
-- ============================================================================

-- Single column value for insert/update operations
CREATE OR REPLACE TYPE t_column_value AS OBJECT (
    column_name VARCHAR2(128),
    col_value VARCHAR2(4000),
    value_type VARCHAR2(30)  -- STRING, NUMBER, DATE, TIMESTAMP, NULL
);
/

-- Collection of column values
CREATE OR REPLACE TYPE t_column_values AS TABLE OF t_column_value;
/

-- Filter condition for WHERE clauses
CREATE OR REPLACE TYPE t_filter_condition AS OBJECT (
    column_name VARCHAR2(128),
    operator VARCHAR2(20),  -- =, <>, <, >, <=, >=, LIKE, IN, IS NULL, IS NOT NULL
    filter_val VARCHAR2(4000),
    value_type VARCHAR2(30),  -- STRING, NUMBER, DATE, TIMESTAMP
    
    -- Generate SQL fragment for this filter condition (bind_idx passed by caller)
    MEMBER FUNCTION to_sql(p_bind_idx NUMBER) RETURN VARCHAR2
);
/

CREATE OR REPLACE TYPE BODY t_filter_condition AS
    MEMBER FUNCTION to_sql(p_bind_idx NUMBER) RETURN VARCHAR2 IS
        v_sql VARCHAR2(500);
        v_op VARCHAR2(20);
    BEGIN
        v_sql := UPPER(SELF.column_name);
        v_op := UPPER(TRIM(SELF.operator));
        
        -- Validate operator against strict whitelist to prevent SQL injection
        IF v_op = 'IS NULL' THEN
            v_sql := v_sql || ' IS NULL';
        ELSIF v_op = 'IS NOT NULL' THEN
            v_sql := v_sql || ' IS NOT NULL';
        ELSIF v_op IN ('=', '<>', '<', '>', '<=', '>=', 'LIKE') THEN
            v_sql := v_sql || ' ' || v_op || ' :' || p_bind_idx;
        ELSIF v_op = 'IN' THEN
            -- IN operator requires properly formatted bind placeholder
            -- Caller must ensure proper list handling; single bind for now
            v_sql := v_sql || ' IN (:' || p_bind_idx || ')';
        ELSE
            -- Reject invalid operators
            RAISE_APPLICATION_ERROR(-20010, 'Invalid filter operator: ' || SELF.operator);
        END IF;
        
        RETURN v_sql;
    END to_sql;
END;
/

-- Collection of filter conditions
CREATE OR REPLACE TYPE t_filter_conditions AS TABLE OF t_filter_condition;
/

-- Sort specification
CREATE OR REPLACE TYPE t_sort_spec AS OBJECT (
    column_name VARCHAR2(128),
    direction VARCHAR2(4)  -- ASC or DESC
);
/

-- Collection of sort specifications
CREATE OR REPLACE TYPE t_sort_specs AS TABLE OF t_sort_spec;
/

-- Result object for CRUD operations
CREATE OR REPLACE TYPE t_crud_result AS OBJECT (
    success NUMBER(1),
    generated_id NUMBER,
    rows_affected NUMBER,
    error_code VARCHAR2(30),
    error_message VARCHAR2(4000),
    
    -- Static constructor for success result
    STATIC FUNCTION ok(p_id NUMBER, p_rows NUMBER) RETURN t_crud_result,
    
    -- Static constructor for error result
    STATIC FUNCTION err(p_code VARCHAR2, p_message VARCHAR2) RETURN t_crud_result
);
/

CREATE OR REPLACE TYPE BODY t_crud_result AS
    STATIC FUNCTION ok(p_id NUMBER, p_rows NUMBER) RETURN t_crud_result IS
    BEGIN
        RETURN t_crud_result(1, p_id, p_rows, NULL, NULL);
    END ok;
    
    STATIC FUNCTION err(p_code VARCHAR2, p_message VARCHAR2) RETURN t_crud_result IS
    BEGIN
        RETURN t_crud_result(0, NULL, 0, p_code, p_message);
    END err;
END;
/

-- ============================================================================
-- PACKAGE SPECIFICATION - Dynamic CRUD v2
-- ============================================================================

CREATE OR REPLACE PACKAGE pkg_crud AS
    
    -- Error codes
    c_err_table_not_allowed  CONSTANT VARCHAR2(30) := 'TABLE_NOT_ALLOWED';
    c_err_column_not_found   CONSTANT VARCHAR2(30) := 'COLUMN_NOT_FOUND';
    c_err_invalid_operation  CONSTANT VARCHAR2(30) := 'INVALID_OPERATION';
    c_err_tenant_required    CONSTANT VARCHAR2(30) := 'TENANT_REQUIRED';
    c_err_not_found          CONSTANT VARCHAR2(30) := 'NOT_FOUND';
    c_err_execution_failed   CONSTANT VARCHAR2(30) := 'EXECUTION_FAILED';
    c_err_permission_denied  CONSTANT VARCHAR2(30) := 'PERMISSION_DENIED';
    
    -- ========================================================================
    -- TABLE METADATA FUNCTIONS
    -- ========================================================================
    
    -- Check if table exists in data dictionary
    FUNCTION table_exists(p_table_name VARCHAR2, p_schema VARCHAR2 DEFAULT USER) RETURN BOOLEAN;
    
    -- Check if table is allowed for dynamic operations
    FUNCTION is_allowed(
        p_table_name VARCHAR2, 
        p_operation  VARCHAR2 DEFAULT 'SELECT'  -- INSERT, UPDATE, DELETE, SELECT
    ) RETURN BOOLEAN;
    
    -- Get table configuration
    FUNCTION get_table_config(p_table_name VARCHAR2) RETURN crud_allowed_tables%ROWTYPE;
    
    -- Get column metadata from data dictionary
    FUNCTION get_column_meta(
        p_table_name  VARCHAR2, 
        p_column_name VARCHAR2
    ) RETURN t_column_meta;
    
    -- Get all columns for a table
    FUNCTION get_table_columns(p_table_name VARCHAR2) RETURN t_column_metas;
    
    -- Validate column exists in table (uses data dictionary)
    FUNCTION column_exists(
        p_table_name  VARCHAR2, 
        p_column_name VARCHAR2
    ) RETURN BOOLEAN;
    
    -- Build column list from data dictionary (excludes specified columns)
    FUNCTION build_column_list(
        p_table_name     VARCHAR2,
        p_exclude_cols   VARCHAR2 DEFAULT NULL  -- Comma-separated list to exclude
    ) RETURN VARCHAR2;
    
    -- ========================================================================
    -- DYNAMIC CRUD OPERATIONS
    -- ========================================================================
    
    -- Generic INSERT - uses data dictionary for column validation and type conversion
    FUNCTION do_insert(
        p_table_name   VARCHAR2,
        p_tenant_id    VARCHAR2,
        p_columns      t_column_values,
        p_created_by   VARCHAR2 DEFAULT NULL
    ) RETURN t_crud_result;
    
    -- Generic SELECT by ID - returns ref cursor
    FUNCTION do_select(
        p_table_name   VARCHAR2,
        p_tenant_id    VARCHAR2,
        p_id           NUMBER,
        p_columns      VARCHAR2 DEFAULT NULL  -- NULL = all columns from data dictionary
    ) RETURN SYS_REFCURSOR;
    
    -- Generic SELECT with filters - returns ref cursor
    FUNCTION do_query(
        p_table_name   VARCHAR2,
        p_tenant_id    VARCHAR2,
        p_columns      VARCHAR2 DEFAULT NULL,
        p_filters      t_filter_conditions DEFAULT NULL,
        p_sort         t_sort_specs DEFAULT NULL,
        p_offset       NUMBER DEFAULT 0,
        p_limit        NUMBER DEFAULT 50
    ) RETURN SYS_REFCURSOR;
    
    -- Generic QUERY with TOTAL (single call for list operations)
    FUNCTION do_query_with_total(
        p_table_name   VARCHAR2,
        p_tenant_id    VARCHAR2,
        p_columns      VARCHAR2 DEFAULT NULL,
        p_filters      t_filter_conditions DEFAULT NULL,
        p_sort         t_sort_specs DEFAULT NULL,
        p_offset       NUMBER DEFAULT 0,
        p_limit        NUMBER DEFAULT 50
    ) RETURN SYS_REFCURSOR;
    
    -- Generic COUNT
    FUNCTION do_count(
        p_table_name   VARCHAR2,
        p_tenant_id    VARCHAR2,
        p_filters      t_filter_conditions DEFAULT NULL
    ) RETURN NUMBER;
    
    -- Generic UPDATE
    FUNCTION do_update(
        p_table_name   VARCHAR2,
        p_tenant_id    VARCHAR2,
        p_id           NUMBER,
        p_columns      t_column_values,
        p_updated_by   VARCHAR2 DEFAULT NULL
    ) RETURN t_crud_result;
    
    -- Generic DELETE (or soft delete if table has 'active' or 'deleted' column)
    FUNCTION do_delete(
        p_table_name   VARCHAR2,
        p_tenant_id    VARCHAR2,
        p_id           NUMBER,
        p_soft_delete  BOOLEAN DEFAULT TRUE,  -- Try soft delete first
        p_deleted_by   VARCHAR2 DEFAULT NULL
    ) RETURN t_crud_result;
    
    -- ========================================================================
    -- AGGREGATE OPERATIONS
    -- ========================================================================
    
    -- Update aggregate using configured expression from crud_allowed_aggregates
    FUNCTION do_aggregate(
        p_parent_table VARCHAR2,
        p_parent_id    NUMBER,
        p_tenant_id    VARCHAR2,
        p_child_table  VARCHAR2
    ) RETURN t_crud_result;
    
    -- ========================================================================
    -- UTILITY PROCEDURES
    -- ========================================================================
    
    -- Register a table for dynamic operations
    PROCEDURE register_table(
        p_table_name    VARCHAR2,
        p_allow_insert  BOOLEAN DEFAULT TRUE,
        p_allow_update  BOOLEAN DEFAULT TRUE,
        p_allow_delete  BOOLEAN DEFAULT TRUE,
        p_require_tenant BOOLEAN DEFAULT TRUE
    );
    
    -- Register an aggregate expression
    PROCEDURE register_aggregate(
        p_parent_table VARCHAR2,
        p_child_table  VARCHAR2,
        p_agg_column   VARCHAR2,
        p_fk_column    VARCHAR2,
        p_expression   VARCHAR2
    );
    
    -- Clear column metadata cache
    PROCEDURE clear_cache;
    
END pkg_crud;
/

-- ============================================================================
-- PACKAGE BODY
-- ============================================================================

CREATE OR REPLACE PACKAGE BODY pkg_crud AS

    -- Session-scoped caches with no TTL - changes to crud_allowed_tables made outside
    -- the register_table flow (e.g., direct SQL*Plus edits) will leave other sessions
    -- with stale entries until they call clear_cache or reconnect. For performance,
    -- maintain only a few active sessions or use register_table for changes.
    -- Reference: t_meta_cache, g_meta_cache, t_config_cache, g_config_cache,
    -- crud_allowed_tables, register_table, clear_cache
    
    -- Column metadata cache
    TYPE t_meta_cache IS TABLE OF t_column_meta INDEX BY VARCHAR2(260);
    g_meta_cache t_meta_cache;
    
    -- Table config cache
    TYPE t_config_cache IS TABLE OF crud_allowed_tables%ROWTYPE INDEX BY VARCHAR2(128);
    g_config_cache t_config_cache;
    
    -- ========================================================================
    -- INTERNAL HELPER FUNCTIONS
    -- ========================================================================
    
    -- Log error to persistent table for diagnostics
    PROCEDURE log_error(p_context VARCHAR2, p_error VARCHAR2) IS
        PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
        INSERT INTO error_log (context, message, severity)
        VALUES (p_context, p_error, 'ERROR');
        COMMIT;
    EXCEPTION
        WHEN OTHERS THEN
            -- Fallback: try to log the logging failure itself
            BEGIN
                INSERT INTO error_log (context, message, severity)
                VALUES ('LOG_ERROR_FAILURE', 'Failed to log error: ' || SQLERRM || ' (original: ' || p_context || ': ' || p_error || ')', 'CRITICAL');
                COMMIT;
            EXCEPTION
                WHEN OTHERS THEN NULL; -- Silent failure if even fallback fails
            END;
    END log_error;
    
    -- Safely quote identifier
    FUNCTION safe_identifier(p_name VARCHAR2) RETURN VARCHAR2 IS
    BEGIN
        RETURN DBMS_ASSERT.SIMPLE_SQL_NAME(UPPER(p_name));
    EXCEPTION
        WHEN OTHERS THEN
            RAISE_APPLICATION_ERROR(-20001, 'Invalid identifier: ' || p_name);
    END safe_identifier;
    
    -- ========================================================================
    -- TABLE METADATA FUNCTIONS
    -- ========================================================================
    
    FUNCTION table_exists(p_table_name VARCHAR2, p_schema VARCHAR2 DEFAULT USER) RETURN BOOLEAN IS
        v_count NUMBER;
    BEGIN
        SELECT COUNT(*) INTO v_count
        FROM all_tables
        WHERE table_name = UPPER(p_table_name)
          AND owner = UPPER(NVL(p_schema, USER));
        RETURN v_count > 0;
    END table_exists;
    
    FUNCTION is_allowed(p_table_name VARCHAR2, p_operation VARCHAR2 DEFAULT 'SELECT') RETURN BOOLEAN IS
        v_config crud_allowed_tables%ROWTYPE;
    BEGIN
        v_config := get_table_config(p_table_name);
        IF v_config.id IS NULL THEN
            RETURN FALSE;
        END IF;
        
        CASE UPPER(p_operation)
            WHEN 'INSERT' THEN RETURN v_config.allow_insert = 1;
            WHEN 'UPDATE' THEN RETURN v_config.allow_update = 1;
            WHEN 'DELETE' THEN RETURN v_config.allow_delete = 1;
            WHEN 'SELECT' THEN RETURN v_config.allow_select = 1;
            ELSE RETURN FALSE;
        END CASE;
    END is_allowed;
    
    FUNCTION get_table_config(p_table_name VARCHAR2) RETURN crud_allowed_tables%ROWTYPE IS
        v_config crud_allowed_tables%ROWTYPE;
        v_key VARCHAR2(128) := UPPER(p_table_name);
    BEGIN
        -- Check cache
        IF g_config_cache.EXISTS(v_key) THEN
            RETURN g_config_cache(v_key);
        END IF;
        
        -- Query config table
        BEGIN
            SELECT * INTO v_config
            FROM crud_allowed_tables
            WHERE table_name = UPPER(p_table_name)
              AND schema_name = USER;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                v_config.id := NULL;
                RETURN v_config;
        END;
        
        -- Cache and return
        g_config_cache(v_key) := v_config;
        RETURN v_config;
    END get_table_config;
    
    FUNCTION get_column_meta(p_table_name VARCHAR2, p_column_name VARCHAR2) RETURN t_column_meta IS
        v_meta t_column_meta;
        v_key VARCHAR2(260) := UPPER(p_table_name) || '.' || UPPER(p_column_name);
    BEGIN
        -- Check cache
        IF g_meta_cache.EXISTS(v_key) THEN
            RETURN g_meta_cache(v_key);
        END IF;
        
        -- Query data dictionary
        SELECT t_column_meta(
            column_name,
            data_type,
            data_length,
            data_precision,
            data_scale,
            nullable
        ) INTO v_meta
        FROM user_tab_columns
        WHERE table_name = UPPER(p_table_name)
          AND column_name = UPPER(p_column_name);
        
        -- Cache and return
        g_meta_cache(v_key) := v_meta;
        RETURN v_meta;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN NULL;
    END get_column_meta;
    
    FUNCTION get_table_columns(p_table_name VARCHAR2) RETURN t_column_metas IS
        v_cols t_column_metas := t_column_metas();
    BEGIN
        FOR rec IN (
            SELECT column_name, data_type, data_length, data_precision, data_scale, nullable
            FROM user_tab_columns
            WHERE table_name = UPPER(p_table_name)
            ORDER BY column_id
        ) LOOP
            v_cols.EXTEND;
            v_cols(v_cols.COUNT) := t_column_meta(
                rec.column_name,
                rec.data_type,
                rec.data_length,
                rec.data_precision,
                rec.data_scale,
                rec.nullable
            );
        END LOOP;
        RETURN v_cols;
    END get_table_columns;
    
    FUNCTION column_exists(p_table_name VARCHAR2, p_column_name VARCHAR2) RETURN BOOLEAN IS
        v_meta t_column_meta;
    BEGIN
        v_meta := get_column_meta(p_table_name, p_column_name);
        RETURN v_meta IS NOT NULL;
    END column_exists;
    
    FUNCTION build_column_list(p_table_name VARCHAR2, p_exclude_cols VARCHAR2 DEFAULT NULL) RETURN VARCHAR2 IS
        v_list VARCHAR2(4000) := '';
        v_exclude VARCHAR2(500) := ',' || UPPER(NVL(p_exclude_cols, '')) || ',';
    BEGIN
        FOR rec IN (
            SELECT column_name
            FROM user_tab_columns
            WHERE table_name = UPPER(p_table_name)
            ORDER BY column_id
        ) LOOP
            IF INSTR(v_exclude, ',' || rec.column_name || ',') = 0 THEN
                IF v_list IS NOT NULL THEN
                    v_list := v_list || ', ';
                END IF;
                v_list := v_list || rec.column_name;
            END IF;
        END LOOP;
        RETURN v_list;
    END build_column_list;
    
    -- ========================================================================
    -- DYNAMIC CRUD OPERATIONS
    -- ========================================================================
    
    FUNCTION do_insert(
        p_table_name   VARCHAR2,
        p_tenant_id    VARCHAR2,
        p_columns      t_column_values,
        p_created_by   VARCHAR2 DEFAULT NULL
    ) RETURN t_crud_result IS
        v_config       crud_allowed_tables%ROWTYPE;
        v_sql          CLOB;
        v_cols         CLOB;
        v_vals         CLOB;
        v_bind_idx     NUMBER := 1;
        v_id           NUMBER;
        v_cursor       NUMBER := NULL; -- Initialize to NULL for safe cleanup
        v_rows         NUMBER;
        v_meta         t_column_meta;
        v_safe_table   VARCHAR2(128);
    BEGIN
        -- Get table config
        v_config := get_table_config(p_table_name);
        IF v_config.id IS NULL OR v_config.allow_insert != 1 THEN
            RETURN t_crud_result.err(c_err_table_not_allowed, 'Table not allowed for INSERT: ' || p_table_name);
        END IF;
        
        v_safe_table := safe_identifier(p_table_name);
        
        -- Check tenant requirement
        IF v_config.require_tenant = 1 THEN
            IF p_tenant_id IS NULL THEN
                RETURN t_crud_result.err(c_err_tenant_required, 'tenant_id is required');
            END IF;
            v_cols := v_config.tenant_column;
            v_vals := ':' || v_bind_idx;
            v_bind_idx := v_bind_idx + 1;
        END IF;
        
        -- Build column list from provided values
        IF p_columns IS NOT NULL THEN
            FOR i IN 1..p_columns.COUNT LOOP
                -- Get column metadata from data dictionary
                v_meta := get_column_meta(p_table_name, p_columns(i).column_name);
                IF v_meta IS NULL THEN
                    RETURN t_crud_result.err(c_err_column_not_found, 
                        'Column not found in table: ' || p_columns(i).column_name);
                END IF;
                
                IF v_cols IS NOT NULL THEN
                    v_cols := v_cols || ', ';
                    v_vals := v_vals || ', ';
                END IF;
                
                v_cols := v_cols || safe_identifier(p_columns(i).column_name);
                v_vals := v_vals || v_meta.get_bind_expression(v_bind_idx);
                v_bind_idx := v_bind_idx + 1;
            END LOOP;
        END IF;
        
        -- Add audit columns if they exist
        IF p_created_by IS NOT NULL THEN
            IF column_exists(p_table_name, 'CREATED_BY') THEN
                v_cols := v_cols || ', CREATED_BY';
                v_vals := v_vals || ', :' || v_bind_idx;
                v_bind_idx := v_bind_idx + 1;
            END IF;
            IF column_exists(p_table_name, 'UPDATED_BY') THEN
                v_cols := v_cols || ', UPDATED_BY';
                v_vals := v_vals || ', :' || v_bind_idx;
                v_bind_idx := v_bind_idx + 1;
            END IF;
        END IF;
        
        -- Build and execute SQL
        v_sql := 'INSERT INTO ' || v_safe_table || 
                 ' (' || v_cols || ') VALUES (' || v_vals || ')' ||
                 ' RETURNING ' || NVL(v_config.id_column, 'ID') || ' INTO :out_id';
        
        v_cursor := DBMS_SQL.OPEN_CURSOR;
        DBMS_SQL.PARSE(v_cursor, v_sql, DBMS_SQL.NATIVE);
        
        -- Bind values
        v_bind_idx := 1;
        
        -- Bind tenant_id if required
        IF v_config.require_tenant = 1 THEN
            DBMS_SQL.BIND_VARIABLE(v_cursor, ':' || v_bind_idx, p_tenant_id);
            v_bind_idx := v_bind_idx + 1;
        END IF;
        
        -- Bind column values
        IF p_columns IS NOT NULL THEN
            FOR i IN 1..p_columns.COUNT LOOP
                DBMS_SQL.BIND_VARIABLE(v_cursor, ':' || v_bind_idx, p_columns(i).col_value);
                v_bind_idx := v_bind_idx + 1;
            END LOOP;
        END IF;
        
        -- Bind audit values
        IF p_created_by IS NOT NULL THEN
            IF column_exists(p_table_name, 'CREATED_BY') THEN
                DBMS_SQL.BIND_VARIABLE(v_cursor, ':' || v_bind_idx, p_created_by);
                v_bind_idx := v_bind_idx + 1;
            END IF;
            IF column_exists(p_table_name, 'UPDATED_BY') THEN
                DBMS_SQL.BIND_VARIABLE(v_cursor, ':' || v_bind_idx, p_created_by);
                v_bind_idx := v_bind_idx + 1;
            END IF;
        END IF;
        
        -- Bind output
        DBMS_SQL.BIND_VARIABLE(v_cursor, ':out_id', v_id);
        
        -- Execute
        v_rows := DBMS_SQL.EXECUTE(v_cursor);
        DBMS_SQL.VARIABLE_VALUE(v_cursor, ':out_id', v_id);
        DBMS_SQL.CLOSE_CURSOR(v_cursor);
        
        RETURN t_crud_result.ok(v_id, v_rows);
        
    EXCEPTION
        WHEN OTHERS THEN
            -- Only close cursor if it was opened (v_cursor is not null and is a valid cursor)
            IF v_cursor IS NOT NULL THEN
                BEGIN
                    IF DBMS_SQL.IS_OPEN(v_cursor) THEN
                        DBMS_SQL.CLOSE_CURSOR(v_cursor);
                    END IF;
                EXCEPTION
                    WHEN OTHERS THEN NULL; -- Ignore cursor cleanup errors
                END;
            END IF;
            log_error('do_insert:' || p_table_name, SQLERRM);
            RETURN t_crud_result.err(c_err_execution_failed, 'Insert failed. See server logs.');
    END do_insert;
    
    FUNCTION do_select(
        p_table_name   VARCHAR2,
        p_tenant_id    VARCHAR2,
        p_id           NUMBER,
        p_columns      VARCHAR2 DEFAULT NULL
    ) RETURN SYS_REFCURSOR IS
        v_config     crud_allowed_tables%ROWTYPE;
        v_cursor     SYS_REFCURSOR;
        v_sql        VARCHAR2(4000);
        v_col_list   VARCHAR2(4000);
        v_safe_table VARCHAR2(128);
    BEGIN
        v_config := get_table_config(p_table_name);
        IF v_config.id IS NULL OR v_config.allow_select != 1 THEN
            RETURN NULL;
        END IF;
        
        v_safe_table := safe_identifier(p_table_name);
        
        -- Build column list from data dictionary if not specified
        IF p_columns IS NULL THEN
            v_col_list := build_column_list(p_table_name);
        ELSE
            -- Validate each column
            DECLARE
                v_cols VARCHAR2(4000) := REPLACE(p_columns, ' ', '');
                v_start NUMBER := 1;
                v_pos NUMBER;
                v_col VARCHAR2(128);
            BEGIN
                v_col_list := '';
                LOOP
                    v_pos := INSTR(v_cols, ',', v_start);
                    IF v_pos = 0 THEN
                        v_col := SUBSTR(v_cols, v_start);
                    ELSE
                        v_col := SUBSTR(v_cols, v_start, v_pos - v_start);
                    END IF;
                    
                    IF v_col IS NOT NULL AND LENGTH(TRIM(v_col)) > 0 THEN
                        IF NOT column_exists(p_table_name, v_col) THEN
                            RETURN NULL;
                        END IF;
                        IF v_col_list IS NOT NULL THEN
                            v_col_list := v_col_list || ', ';
                        END IF;
                        v_col_list := v_col_list || safe_identifier(v_col);
                    END IF;
                    
                    EXIT WHEN v_pos = 0;
                    v_start := v_pos + 1;
                END LOOP;
            END;
        END IF;
        
        -- Build SQL with tenant isolation
        IF v_config.require_tenant = 1 THEN
            v_sql := 'SELECT ' || v_col_list || 
                     ' FROM ' || v_safe_table ||
                     ' WHERE ' || safe_identifier(v_config.tenant_column) || ' = :1' ||
                     ' AND ' || safe_identifier(v_config.id_column) || ' = :2';
            OPEN v_cursor FOR v_sql USING p_tenant_id, p_id;
        ELSE
            v_sql := 'SELECT ' || v_col_list || 
                     ' FROM ' || v_safe_table ||
                     ' WHERE ' || safe_identifier(v_config.id_column) || ' = :1';
            OPEN v_cursor FOR v_sql USING p_id;
        END IF;
        
        RETURN v_cursor;
    EXCEPTION
        WHEN OTHERS THEN
            log_error('do_select:' || p_table_name, SQLERRM);
            RETURN NULL;
    END do_select;
    
    FUNCTION do_query(
        p_table_name   VARCHAR2,
        p_tenant_id    VARCHAR2,
        p_columns      VARCHAR2 DEFAULT NULL,
        p_filters      t_filter_conditions DEFAULT NULL,
        p_sort         t_sort_specs DEFAULT NULL,
        p_offset       NUMBER DEFAULT 0,
        p_limit        NUMBER DEFAULT 50
    ) RETURN SYS_REFCURSOR IS
        v_config     crud_allowed_tables%ROWTYPE;
        v_cursor     SYS_REFCURSOR;
        v_sql        CLOB;
        v_col_list   VARCHAR2(4000);
        v_where      CLOB := '';
        v_order      VARCHAR2(1000) := '';
        v_bind_idx   NUMBER := 1;
        v_safe_table VARCHAR2(128);
        v_dbms_cur   NUMBER := NULL;
        v_dummy      NUMBER;
    BEGIN
        v_config := get_table_config(p_table_name);
        IF v_config.id IS NULL OR v_config.allow_select != 1 THEN
            RETURN NULL;
        END IF;
        
        v_safe_table := safe_identifier(p_table_name);
        
        -- Build column list (validate if provided externally)
        IF p_columns IS NULL THEN
            v_col_list := build_column_list(p_table_name);
        ELSE
            -- SECURITY: Validate p_columns to prevent SQL injection
            -- Parse and validate each column identifier
            DECLARE
                v_cols VARCHAR2(4000) := REPLACE(p_columns, ' ', '');
                v_start NUMBER := 1;
                v_pos NUMBER;
                v_col VARCHAR2(128);
                v_validated_list VARCHAR2(4000) := '';
            BEGIN
                LOOP
                    v_pos := INSTR(v_cols, ',', v_start);
                    IF v_pos = 0 THEN
                        v_col := SUBSTR(v_cols, v_start);
                    ELSE
                        v_col := SUBSTR(v_cols, v_start, v_pos - v_start);
                    END IF;
                    
                    IF v_col IS NOT NULL AND LENGTH(TRIM(v_col)) > 0 THEN
                        -- Validate column exists in table
                        IF NOT column_exists(p_table_name, v_col) THEN
                            log_error('do_query:' || p_table_name, 'Invalid column: ' || v_col);
                            RETURN NULL;
                        END IF;
                        IF v_validated_list IS NOT NULL AND LENGTH(v_validated_list) > 0 THEN
                            v_validated_list := v_validated_list || ', ';
                        END IF;
                        v_validated_list := v_validated_list || safe_identifier(v_col);
                    END IF;
                    
                    EXIT WHEN v_pos = 0;
                    v_start := v_pos + 1;
                END LOOP;
                v_col_list := v_validated_list;
            END;
        END IF;
        
        -- Build WHERE clause
        IF v_config.require_tenant = 1 THEN
            v_where := ' WHERE ' || safe_identifier(v_config.tenant_column) || ' = :' || v_bind_idx;
            v_bind_idx := v_bind_idx + 1;
        END IF;
        
        -- Add filters
        IF p_filters IS NOT NULL AND p_filters.COUNT > 0 THEN
            FOR i IN 1..p_filters.COUNT LOOP
                IF column_exists(p_table_name, p_filters(i).column_name) THEN
                    IF v_where IS NULL THEN
                        v_where := ' WHERE ';
                    ELSE
                        v_where := v_where || ' AND ';
                    END IF;
                    v_where := v_where || p_filters(i).to_sql(v_bind_idx);
                    -- Increment bind index if operator uses a bind variable
                    IF UPPER(p_filters(i).operator) NOT IN ('IS NULL', 'IS NOT NULL') THEN
                        v_bind_idx := v_bind_idx + 1;
                    END IF;
                END IF;
            END LOOP;
        END IF;
        
        -- Build ORDER BY
        IF p_sort IS NOT NULL AND p_sort.COUNT > 0 THEN
            FOR i IN 1..p_sort.COUNT LOOP
                IF column_exists(p_table_name, p_sort(i).column_name) THEN
                    -- Validate direction to prevent SQL injection
                    DECLARE
                        v_direction VARCHAR2(4);
                    BEGIN
                        v_direction := UPPER(TRIM(p_sort(i).direction));
                        IF v_direction NOT IN ('ASC', 'DESC') THEN
                            v_direction := 'ASC'; -- Default to ASC for invalid values
                        END IF;
                        
                        IF v_order IS NULL OR LENGTH(v_order) = 0 THEN
                            v_order := ' ORDER BY ';
                        ELSE
                            v_order := v_order || ', ';
                        END IF;
                        v_order := v_order || safe_identifier(p_sort(i).column_name) || ' ' || v_direction;
                    END;
                END IF;
            END LOOP;
        END IF;
        
        IF v_order IS NULL OR LENGTH(v_order) = 0 THEN
            v_order := ' ORDER BY ' || safe_identifier(v_config.id_column) || ' DESC';
        END IF;
        
        -- Build full SQL
        v_sql := 'SELECT ' || v_col_list ||
                 ' FROM ' || v_safe_table ||
                 v_where || v_order ||
                 ' OFFSET :off ROWS FETCH NEXT :lim ROWS ONLY';
        
        -- Execute with DBMS_SQL for dynamic binding
        v_dbms_cur := DBMS_SQL.OPEN_CURSOR;
        DBMS_SQL.PARSE(v_dbms_cur, v_sql, DBMS_SQL.NATIVE);
        
        v_bind_idx := 1;
        IF v_config.require_tenant = 1 THEN
            DBMS_SQL.BIND_VARIABLE(v_dbms_cur, ':' || v_bind_idx, p_tenant_id);
            v_bind_idx := v_bind_idx + 1;
        END IF;
        
        IF p_filters IS NOT NULL THEN
            FOR i IN 1..p_filters.COUNT LOOP
                IF column_exists(p_table_name, p_filters(i).column_name) THEN
                    IF UPPER(p_filters(i).operator) NOT IN ('IS NULL', 'IS NOT NULL') THEN
                        DBMS_SQL.BIND_VARIABLE(v_dbms_cur, ':' || v_bind_idx, p_filters(i).filter_val);
                        v_bind_idx := v_bind_idx + 1;
                    END IF;
                END IF;
            END LOOP;
        END IF;
        
        DBMS_SQL.BIND_VARIABLE(v_dbms_cur, ':off', p_offset);
        DBMS_SQL.BIND_VARIABLE(v_dbms_cur, ':lim', p_limit);
        
        v_dummy := DBMS_SQL.EXECUTE(v_dbms_cur);
        v_cursor := DBMS_SQL.TO_REFCURSOR(v_dbms_cur);
        
        RETURN v_cursor;
        
    EXCEPTION
        WHEN OTHERS THEN
            IF DBMS_SQL.IS_OPEN(v_dbms_cur) THEN
                DBMS_SQL.CLOSE_CURSOR(v_dbms_cur);
            END IF;
            log_error('do_query:' || p_table_name, SQLERRM);
            RETURN NULL;
    END do_query;
    
    -- Query with total count in single call (for list operations)
    FUNCTION do_query_with_total(
        p_table_name   VARCHAR2,
        p_tenant_id    VARCHAR2,
        p_columns      VARCHAR2 DEFAULT NULL,
        p_filters      t_filter_conditions DEFAULT NULL,
        p_sort         t_sort_specs DEFAULT NULL,
        p_offset       NUMBER DEFAULT 0,
        p_limit        NUMBER DEFAULT 50
    ) RETURN SYS_REFCURSOR IS
        v_config     crud_allowed_tables%ROWTYPE;
        v_cursor     SYS_REFCURSOR;
        v_sql        CLOB;
        v_col_list   VARCHAR2(4000);
        v_where      CLOB := '';
        v_order      VARCHAR2(1000) := '';
        v_bind_idx   NUMBER := 1;
        v_safe_table VARCHAR2(128);
        v_dbms_cur   NUMBER := NULL;
        v_dummy      NUMBER;
    BEGIN
        v_config := get_table_config(p_table_name);
        IF v_config.id IS NULL OR v_config.allow_select != 1 THEN
            RETURN NULL;
        END IF;
        
        v_safe_table := safe_identifier(p_table_name);
        
        -- Build column list (validate if provided externally)
        IF p_columns IS NULL THEN
            v_col_list := build_column_list(p_table_name);
        ELSE
            -- SECURITY: Validate p_columns to prevent SQL injection
            -- Parse and validate each column identifier
            DECLARE
                v_cols VARCHAR2(4000) := REPLACE(p_columns, ' ', '');
                v_start NUMBER := 1;
                v_pos NUMBER;
                v_col VARCHAR2(128);
                v_validated_list VARCHAR2(4000) := '';
            BEGIN
                LOOP
                    v_pos := INSTR(v_cols, ',', v_start);
                    IF v_pos = 0 THEN
                        v_col := SUBSTR(v_cols, v_start);
                    ELSE
                        v_col := SUBSTR(v_cols, v_start, v_pos - v_start);
                    END IF;
                    
                    IF v_col IS NOT NULL AND LENGTH(TRIM(v_col)) > 0 THEN
                        -- Validate column exists in table
                        IF NOT column_exists(p_table_name, v_col) THEN
                            log_error('do_query_with_total:' || p_table_name, 'Invalid column: ' || v_col);
                            RETURN NULL;
                        END IF;
                        IF v_validated_list IS NOT NULL AND LENGTH(v_validated_list) > 0 THEN
                            v_validated_list := v_validated_list || ', ';
                        END IF;
                        v_validated_list := v_validated_list || safe_identifier(v_col);
                    END IF;
                    
                    EXIT WHEN v_pos = 0;
                    v_start := v_bind_idx + 1;
                END LOOP;
                v_col_list := v_validated_list;
            END;
        END IF;
        
        -- Build WHERE clause
        IF v_config.require_tenant = 1 THEN
            v_where := ' WHERE ' || safe_identifier(v_config.tenant_column) || ' = :' || v_bind_idx;
            v_bind_idx := v_bind_idx + 1;
        END IF;
        
        -- Add filters
        IF p_filters IS NOT NULL AND p_filters.COUNT > 0 THEN
            FOR i IN 1..p_filters.COUNT LOOP
                IF column_exists(p_table_name, p_filters(i).column_name) THEN
                    IF v_where IS NULL THEN
                        v_where := ' WHERE ';
                    ELSE
                        v_where := v_where || ' AND ';
                    END IF;
                    v_where := v_where || p_filters(i).to_sql(v_bind_idx);
                    -- Increment bind index if operator uses a bind variable
                    IF UPPER(p_filters(i).operator) NOT IN ('IS NULL', 'IS NOT NULL') THEN
                        v_bind_idx := v_bind_idx + 1;
                    END IF;
                END IF;
            END LOOP;
        END IF;
        
        -- Build ORDER BY
        IF p_sort IS NOT NULL AND p_sort.COUNT > 0 THEN
            FOR i IN 1..p_sort.COUNT LOOP
                IF column_exists(p_table_name, p_sort(i).column_name) THEN
                    -- Validate direction to prevent SQL injection
                    DECLARE
                        v_direction VARCHAR2(4);
                    BEGIN
                        v_direction := UPPER(TRIM(p_sort(i).direction));
                        IF v_direction NOT IN ('ASC', 'DESC') THEN
                            v_direction := 'ASC'; -- Default to ASC for invalid values
                        END IF;
                        
                        IF v_order IS NULL OR LENGTH(v_order) = 0 THEN
                            v_order := ' ORDER BY ';
                        ELSE
                            v_order := v_order || ', ';
                        END IF;
                        v_order := v_order || safe_identifier(p_sort(i).column_name) || ' ' || v_direction;
                    END;
                END IF;
            END LOOP;
        END IF;
        
        IF v_order IS NULL OR LENGTH(v_order) = 0 THEN
            v_order := ' ORDER BY ' || safe_identifier(v_config.id_column) || ' DESC';
        END IF;
        
        -- Build full SQL with COUNT(*) OVER() as first column for total
        v_sql := 'SELECT COUNT(*) OVER() AS total_count, ' || v_col_list ||
                 ' FROM ' || v_safe_table ||
                 v_where || v_order ||
                 ' OFFSET :off ROWS FETCH NEXT :lim ROWS ONLY';
        
        -- Execute with DBMS_SQL for dynamic binding
        v_dbms_cur := DBMS_SQL.OPEN_CURSOR;
        DBMS_SQL.PARSE(v_dbms_cur, v_sql, DBMS_SQL.NATIVE);
        
        v_bind_idx := 1;
        -- Bind tenant filter
        IF v_config.require_tenant = 1 THEN
            DBMS_SQL.BIND_VARIABLE(v_dbms_cur, ':' || v_bind_idx, p_tenant_id);
            v_bind_idx := v_bind_idx + 1;
        END IF;
        
        -- Bind filter values
        IF p_filters IS NOT NULL AND p_filters.COUNT > 0 THEN
            FOR i IN 1..p_filters.COUNT LOOP
                IF column_exists(p_table_name, p_filters(i).column_name) THEN
                    IF UPPER(p_filters(i).operator) NOT IN ('IS NULL', 'IS NOT NULL') THEN
                        DBMS_SQL.BIND_VARIABLE(v_dbms_cur, ':' || v_bind_idx, p_filters(i).filter_val);
                        v_bind_idx := v_bind_idx + 1;
                    END IF;
                END IF;
            END LOOP;
        END IF;
        
        DBMS_SQL.BIND_VARIABLE(v_dbms_cur, ':off', p_offset);
        DBMS_SQL.BIND_VARIABLE(v_dbms_cur, ':lim', p_limit);
        
        v_dummy := DBMS_SQL.EXECUTE(v_dbms_cur);
        v_cursor := DBMS_SQL.TO_REFCURSOR(v_dbms_cur);
        
        RETURN v_cursor;
        
    EXCEPTION
        WHEN OTHERS THEN
            IF DBMS_SQL.IS_OPEN(v_dbms_cur) THEN
                DBMS_SQL.CLOSE_CURSOR(v_dbms_cur);
            END IF;
            log_error('do_query_with_total:' || p_table_name, SQLERRM);
            RETURN NULL;
    END do_query_with_total;
    
    FUNCTION do_count(
        p_table_name   VARCHAR2,
        p_tenant_id    VARCHAR2,
        p_filters      t_filter_conditions DEFAULT NULL
    ) RETURN NUMBER IS
        v_config     crud_allowed_tables%ROWTYPE;
        v_sql        CLOB;
        v_where      CLOB := '';
        v_bind_idx   NUMBER := 1;
        v_count      NUMBER;
        v_cursor     NUMBER;
        v_dummy      NUMBER;
        v_safe_table VARCHAR2(128);
    BEGIN
        v_config := get_table_config(p_table_name);
        IF v_config.id IS NULL OR v_config.allow_select != 1 THEN
            RETURN -1;
        END IF;
        
        v_safe_table := safe_identifier(p_table_name);
        
        -- Build WHERE
        IF v_config.require_tenant = 1 THEN
            v_where := ' WHERE ' || safe_identifier(v_config.tenant_column) || ' = :' || v_bind_idx;
            v_bind_idx := v_bind_idx + 1;
        END IF;
        
        IF p_filters IS NOT NULL AND p_filters.COUNT > 0 THEN
            FOR i IN 1..p_filters.COUNT LOOP
                IF column_exists(p_table_name, p_filters(i).column_name) THEN
                    IF v_where IS NULL THEN
                        v_where := ' WHERE ';
                    ELSE
                        v_where := v_where || ' AND ';
                    END IF;
                    v_where := v_where || p_filters(i).to_sql(v_bind_idx);
                    -- Increment bind index if operator uses a bind variable
                    IF UPPER(p_filters(i).operator) NOT IN ('IS NULL', 'IS NOT NULL') THEN
                        v_bind_idx := v_bind_idx + 1;
                    END IF;
                END IF;
            END LOOP;
        END IF;
        
        v_sql := 'SELECT COUNT(*) FROM ' || v_safe_table || v_where;
        
        v_cursor := DBMS_SQL.OPEN_CURSOR;
        DBMS_SQL.PARSE(v_cursor, v_sql, DBMS_SQL.NATIVE);
        
        v_bind_idx := 1;
        IF v_config.require_tenant = 1 THEN
            DBMS_SQL.BIND_VARIABLE(v_cursor, ':' || v_bind_idx, p_tenant_id);
            v_bind_idx := v_bind_idx + 1;
        END IF;
        
        IF p_filters IS NOT NULL THEN
            FOR i IN 1..p_filters.COUNT LOOP
                IF column_exists(p_table_name, p_filters(i).column_name) THEN
                    IF UPPER(p_filters(i).operator) NOT IN ('IS NULL', 'IS NOT NULL') THEN
                        DBMS_SQL.BIND_VARIABLE(v_cursor, ':' || v_bind_idx, p_filters(i).filter_val);
                        v_bind_idx := v_bind_idx + 1;
                    END IF;
                END IF;
            END LOOP;
        END IF;
        
        DBMS_SQL.DEFINE_COLUMN(v_cursor, 1, v_count);
        v_dummy := DBMS_SQL.EXECUTE(v_cursor);
        
        IF DBMS_SQL.FETCH_ROWS(v_cursor) > 0 THEN
            DBMS_SQL.COLUMN_VALUE(v_cursor, 1, v_count);
        ELSE
            v_count := 0;
        END IF;
        
        DBMS_SQL.CLOSE_CURSOR(v_cursor);
        RETURN v_count;
        
    EXCEPTION
        WHEN OTHERS THEN
            IF DBMS_SQL.IS_OPEN(v_cursor) THEN
                DBMS_SQL.CLOSE_CURSOR(v_cursor);
            END IF;
            log_error('do_count:' || p_table_name, SQLERRM);
            RETURN -1;
    END do_count;
    
    FUNCTION do_update(
        p_table_name   VARCHAR2,
        p_tenant_id    VARCHAR2,
        p_id           NUMBER,
        p_columns      t_column_values,
        p_updated_by   VARCHAR2 DEFAULT NULL
    ) RETURN t_crud_result IS
        v_config     crud_allowed_tables%ROWTYPE;
        v_sql        CLOB;
        v_set        CLOB := '';
        v_bind_idx   NUMBER := 1;
        v_cursor     NUMBER;
        v_rows       NUMBER;
        v_meta       t_column_meta;
        v_safe_table VARCHAR2(128);
    BEGIN
        v_config := get_table_config(p_table_name);
        IF v_config.id IS NULL OR v_config.allow_update != 1 THEN
            RETURN t_crud_result.err(c_err_table_not_allowed, 'Table not allowed for UPDATE: ' || p_table_name);
        END IF;
        
        IF p_columns IS NULL OR p_columns.COUNT = 0 THEN
            RETURN t_crud_result.err(c_err_invalid_operation, 'No columns to update');
        END IF;
        
        v_safe_table := safe_identifier(p_table_name);
        
        -- Build SET clause
        FOR i IN 1..p_columns.COUNT LOOP
            v_meta := get_column_meta(p_table_name, p_columns(i).column_name);
            IF v_meta IS NULL THEN
                RETURN t_crud_result.err(c_err_column_not_found, 
                    'Column not found: ' || p_columns(i).column_name);
            END IF;
            
            IF v_set IS NOT NULL AND LENGTH(v_set) > 0 THEN
                v_set := v_set || ', ';
            END IF;
            
            IF p_columns(i).col_value IS NULL OR p_columns(i).value_type = 'NULL' THEN
                v_set := v_set || safe_identifier(p_columns(i).column_name) || ' = NULL';
            ELSE
                v_set := v_set || safe_identifier(p_columns(i).column_name) || 
                         ' = ' || v_meta.get_bind_expression(v_bind_idx);
                v_bind_idx := v_bind_idx + 1;
            END IF;
        END LOOP;
        
        -- Add audit columns
        IF column_exists(p_table_name, 'UPDATED_AT') THEN
            v_set := v_set || ', UPDATED_AT = CURRENT_TIMESTAMP';
        END IF;
        IF p_updated_by IS NOT NULL AND column_exists(p_table_name, 'UPDATED_BY') THEN
            v_set := v_set || ', UPDATED_BY = :upd_by';
        END IF;
        
        -- Build SQL
        IF v_config.require_tenant = 1 THEN
            v_sql := 'UPDATE ' || v_safe_table || 
                     ' SET ' || v_set ||
                     ' WHERE ' || safe_identifier(v_config.tenant_column) || ' = :tenant' ||
                     ' AND ' || safe_identifier(v_config.id_column) || ' = :id';
        ELSE
            v_sql := 'UPDATE ' || v_safe_table || 
                     ' SET ' || v_set ||
                     ' WHERE ' || safe_identifier(v_config.id_column) || ' = :id';
        END IF;
        
        -- Execute
        v_cursor := DBMS_SQL.OPEN_CURSOR;
        DBMS_SQL.PARSE(v_cursor, v_sql, DBMS_SQL.NATIVE);
        
        v_bind_idx := 1;
        FOR i IN 1..p_columns.COUNT LOOP
            IF p_columns(i).col_value IS NOT NULL AND p_columns(i).value_type != 'NULL' THEN
                DBMS_SQL.BIND_VARIABLE(v_cursor, ':' || v_bind_idx, p_columns(i).col_value);
                v_bind_idx := v_bind_idx + 1;
            END IF;
        END LOOP;
        
        IF p_updated_by IS NOT NULL AND column_exists(p_table_name, 'UPDATED_BY') THEN
            DBMS_SQL.BIND_VARIABLE(v_cursor, ':upd_by', p_updated_by);
        END IF;
        
        IF v_config.require_tenant = 1 THEN
            DBMS_SQL.BIND_VARIABLE(v_cursor, ':tenant', p_tenant_id);
        END IF;
        DBMS_SQL.BIND_VARIABLE(v_cursor, ':id', p_id);
        
        v_rows := DBMS_SQL.EXECUTE(v_cursor);
        DBMS_SQL.CLOSE_CURSOR(v_cursor);
        
        IF v_rows = 0 THEN
            RETURN t_crud_result.err(c_err_not_found, 'Record not found');
        END IF;
        
        RETURN t_crud_result.ok(p_id, v_rows);
        
    EXCEPTION
        WHEN OTHERS THEN
            IF DBMS_SQL.IS_OPEN(v_cursor) THEN
                DBMS_SQL.CLOSE_CURSOR(v_cursor);
            END IF;
            log_error('do_update:' || p_table_name, SQLERRM);
            RETURN t_crud_result.err(c_err_execution_failed, 'Update failed. See server logs.');
    END do_update;
    
    FUNCTION do_delete(
        p_table_name   VARCHAR2,
        p_tenant_id    VARCHAR2,
        p_id           NUMBER,
        p_soft_delete  BOOLEAN DEFAULT TRUE,
        p_deleted_by   VARCHAR2 DEFAULT NULL
    ) RETURN t_crud_result IS
        v_config     crud_allowed_tables%ROWTYPE;
        v_sql        VARCHAR2(4000);
        v_rows       NUMBER;
        v_safe_table VARCHAR2(128);
    BEGIN
        v_config := get_table_config(p_table_name);
        IF v_config.id IS NULL OR v_config.allow_delete != 1 THEN
            RETURN t_crud_result.err(c_err_table_not_allowed, 'Table not allowed for DELETE: ' || p_table_name);
        END IF;
        
        v_safe_table := safe_identifier(p_table_name);
        
        -- Try soft delete first if requested
        IF p_soft_delete THEN
            IF column_exists(p_table_name, 'ACTIVE') THEN
                DECLARE
                    v_set_clause VARCHAR2(400) := 'ACTIVE = 0';
                    v_set_clause_no_tenant VARCHAR2(400) := 'ACTIVE = 0';
                BEGIN
                    IF column_exists(p_table_name, 'UPDATED_AT') THEN
                        v_set_clause := v_set_clause || ', UPDATED_AT = CURRENT_TIMESTAMP';
                        v_set_clause_no_tenant := v_set_clause_no_tenant || ', UPDATED_AT = CURRENT_TIMESTAMP';
                    END IF;
                    IF column_exists(p_table_name, 'DELETED_BY') AND p_deleted_by IS NOT NULL THEN
                        v_set_clause := v_set_clause || ', DELETED_BY = :3';
                        v_set_clause_no_tenant := v_set_clause_no_tenant || ', DELETED_BY = :2';
                    END IF;

                IF v_config.require_tenant = 1 THEN
                    v_sql := 'UPDATE ' || v_safe_table || 
                             ' SET ' || v_set_clause ||
                             ' WHERE ' || safe_identifier(v_config.tenant_column) || ' = :1' ||
                             ' AND ' || safe_identifier(v_config.id_column) || ' = :2';
                    IF INSTR(v_set_clause, ':3') > 0 THEN
                        EXECUTE IMMEDIATE v_sql USING p_tenant_id, p_id, p_deleted_by;
                    ELSE
                        EXECUTE IMMEDIATE v_sql USING p_tenant_id, p_id;
                    END IF;
                ELSE
                    v_sql := 'UPDATE ' || v_safe_table || 
                             ' SET ' || v_set_clause_no_tenant ||
                             ' WHERE ' || safe_identifier(v_config.id_column) || ' = :1';
                    IF INSTR(v_set_clause_no_tenant, ':2') > 0 THEN
                        EXECUTE IMMEDIATE v_sql USING p_id, p_deleted_by;
                    ELSE
                        EXECUTE IMMEDIATE v_sql USING p_id;
                    END IF;
                END IF;
                END;
                v_rows := SQL%ROWCOUNT;
                
                IF v_rows > 0 THEN
                    RETURN t_crud_result.ok(p_id, v_rows);
                END IF;
            ELSIF column_exists(p_table_name, 'DELETED_AT') THEN
                -- Build SET clause for DELETED_AT and optionally UPDATED_AT
                DECLARE
                    v_set_clause VARCHAR2(200) := 'DELETED_AT = CURRENT_TIMESTAMP';
                    v_set_clause_no_tenant VARCHAR2(200) := 'DELETED_AT = CURRENT_TIMESTAMP';
                BEGIN
                    IF column_exists(p_table_name, 'UPDATED_AT') THEN
                        v_set_clause := v_set_clause || ', UPDATED_AT = CURRENT_TIMESTAMP';
                        v_set_clause_no_tenant := v_set_clause_no_tenant || ', UPDATED_AT = CURRENT_TIMESTAMP';
                    END IF;
                    IF column_exists(p_table_name, 'DELETED_BY') AND p_deleted_by IS NOT NULL THEN
                        v_set_clause := v_set_clause || ', DELETED_BY = :3';
                        v_set_clause_no_tenant := v_set_clause_no_tenant || ', DELETED_BY = :2';
                    END IF;
                    
                    IF v_config.require_tenant = 1 THEN
                        v_sql := 'UPDATE ' || v_safe_table || 
                                 ' SET ' || v_set_clause ||
                                 ' WHERE ' || safe_identifier(v_config.tenant_column) || ' = :1' ||
                                 ' AND ' || safe_identifier(v_config.id_column) || ' = :2';
                        IF INSTR(v_set_clause, ':3') > 0 THEN
                            EXECUTE IMMEDIATE v_sql USING p_tenant_id, p_id, p_deleted_by;
                        ELSE
                            EXECUTE IMMEDIATE v_sql USING p_tenant_id, p_id;
                        END IF;
                    ELSE
                        v_sql := 'UPDATE ' || v_safe_table || 
                                 ' SET ' || v_set_clause_no_tenant ||
                                 ' WHERE ' || safe_identifier(v_config.id_column) || ' = :1';
                        IF INSTR(v_set_clause_no_tenant, ':2') > 0 THEN
                            EXECUTE IMMEDIATE v_sql USING p_id, p_deleted_by;
                        ELSE
                            EXECUTE IMMEDIATE v_sql USING p_id;
                        END IF;
                    END IF;
                END;
                v_rows := SQL%ROWCOUNT;
                
                IF v_rows > 0 THEN
                    RETURN t_crud_result.ok(p_id, v_rows);
                END IF;
            END IF;
        END IF;
        
        -- Hard delete
        IF v_config.require_tenant = 1 THEN
            v_sql := 'DELETE FROM ' || v_safe_table || 
                     ' WHERE ' || safe_identifier(v_config.tenant_column) || ' = :1' ||
                     ' AND ' || safe_identifier(v_config.id_column) || ' = :2';
            EXECUTE IMMEDIATE v_sql USING p_tenant_id, p_id;
        ELSE
            v_sql := 'DELETE FROM ' || v_safe_table || 
                     ' WHERE ' || safe_identifier(v_config.id_column) || ' = :1';
            EXECUTE IMMEDIATE v_sql USING p_id;
        END IF;
        
        v_rows := SQL%ROWCOUNT;
        
        IF v_rows = 0 THEN
            RETURN t_crud_result.err(c_err_not_found, 'Record not found');
        END IF;
        
        RETURN t_crud_result.ok(p_id, v_rows);
        
    EXCEPTION
        WHEN OTHERS THEN
            log_error('do_delete:' || p_table_name, SQLERRM);
            RETURN t_crud_result.err(c_err_execution_failed, 'Delete failed. See server logs.');
    END do_delete;
    
    -- ========================================================================
    -- AGGREGATE OPERATIONS
    -- ========================================================================
    
    FUNCTION do_aggregate(
        p_parent_table VARCHAR2,
        p_parent_id    NUMBER,
        p_tenant_id    VARCHAR2,
        p_child_table  VARCHAR2
    ) RETURN t_crud_result IS
        v_agg_config crud_allowed_aggregates%ROWTYPE;
        v_parent_cfg crud_allowed_tables%ROWTYPE;
        v_child_cfg  crud_allowed_tables%ROWTYPE;
        v_sql        VARCHAR2(4000);
        v_rows       NUMBER;
    BEGIN
        -- Get aggregate configuration
        BEGIN
            SELECT * INTO v_agg_config
            FROM crud_allowed_aggregates
            WHERE parent_table = UPPER(p_parent_table)
              AND child_table = UPPER(p_child_table);
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                RETURN t_crud_result.err(c_err_invalid_operation, 
                    'No aggregate configured for ' || p_parent_table || ' <- ' || p_child_table);
        END;
        
        -- Validate tables
        v_parent_cfg := get_table_config(p_parent_table);
        v_child_cfg := get_table_config(p_child_table);
        
        IF v_parent_cfg.id IS NULL OR v_child_cfg.id IS NULL THEN
            RETURN t_crud_result.err(c_err_table_not_allowed, 'Tables not configured');
        END IF;
        
        -- Validate columns exist
        IF NOT column_exists(p_parent_table, v_agg_config.agg_column) THEN
            RETURN t_crud_result.err(c_err_column_not_found, 'Aggregate column not found: ' || v_agg_config.agg_column);
        END IF;
        IF NOT column_exists(p_child_table, v_agg_config.fk_column) THEN
            RETURN t_crud_result.err(c_err_column_not_found, 'FK column not found: ' || v_agg_config.fk_column);
        END IF;
        
        -- Build and execute aggregate update
        v_sql := 'UPDATE ' || safe_identifier(p_parent_table) ||
                 ' SET ' || safe_identifier(v_agg_config.agg_column) || ' = COALESCE((' ||
                 'SELECT ' || v_agg_config.expression ||
                 ' FROM ' || safe_identifier(p_child_table) ||
                 ' WHERE ' || safe_identifier(v_child_cfg.tenant_column) || ' = :1' ||
                 ' AND ' || safe_identifier(v_agg_config.fk_column) || ' = :2), 0)';
        
        IF column_exists(p_parent_table, 'UPDATED_AT') THEN
            v_sql := v_sql || ', UPDATED_AT = CURRENT_TIMESTAMP';
        END IF;
        
        v_sql := v_sql || ' WHERE ' || safe_identifier(v_parent_cfg.tenant_column) || ' = :3' ||
                 ' AND ' || safe_identifier(v_parent_cfg.id_column) || ' = :4';
        
        EXECUTE IMMEDIATE v_sql USING p_tenant_id, p_parent_id, p_tenant_id, p_parent_id;
        v_rows := SQL%ROWCOUNT;
        
        IF v_rows = 0 THEN
            RETURN t_crud_result.err(c_err_not_found, 'Parent record not found');
        END IF;
        
        RETURN t_crud_result.ok(p_parent_id, v_rows);
        
    EXCEPTION
        WHEN OTHERS THEN
            log_error('do_aggregate:' || p_parent_table, SQLERRM);
            RETURN t_crud_result.err(c_err_execution_failed, 'Aggregate update failed. See server logs.');
    END do_aggregate;
    
    -- ========================================================================
    -- UTILITY PROCEDURES
    -- ========================================================================
    
    PROCEDURE register_table(
        p_table_name    VARCHAR2,
        p_allow_insert  BOOLEAN DEFAULT TRUE,
        p_allow_update  BOOLEAN DEFAULT TRUE,
        p_allow_delete  BOOLEAN DEFAULT TRUE,
        p_require_tenant BOOLEAN DEFAULT TRUE
    ) IS
    BEGIN
        MERGE INTO crud_allowed_tables t
        USING (SELECT UPPER(p_table_name) AS table_name, USER AS schema_name FROM dual) s
        ON (t.table_name = s.table_name AND t.schema_name = s.schema_name)
        WHEN MATCHED THEN
            UPDATE SET 
                allow_insert = CASE WHEN p_allow_insert THEN 1 ELSE 0 END,
                allow_update = CASE WHEN p_allow_update THEN 1 ELSE 0 END,
                allow_delete = CASE WHEN p_allow_delete THEN 1 ELSE 0 END,
                require_tenant = CASE WHEN p_require_tenant THEN 1 ELSE 0 END
        WHEN NOT MATCHED THEN
            INSERT (table_name, schema_name, allow_insert, allow_update, allow_delete, require_tenant)
            VALUES (UPPER(p_table_name), USER, 
                    CASE WHEN p_allow_insert THEN 1 ELSE 0 END,
                    CASE WHEN p_allow_update THEN 1 ELSE 0 END,
                    CASE WHEN p_allow_delete THEN 1 ELSE 0 END,
                    CASE WHEN p_require_tenant THEN 1 ELSE 0 END);
        
        -- Clear cache
        g_config_cache.DELETE(UPPER(p_table_name));
    END register_table;
    
    -- Validate aggregate expression for safety
    -- Only allows: aggregate functions, column names, arithmetic, NVL/COALESCE
    FUNCTION validate_aggregate_expr(p_expr VARCHAR2) RETURN BOOLEAN IS
        v_upper VARCHAR2(500) := UPPER(TRIM(p_expr));
        v_dangerous_pattern VARCHAR2(200);
    BEGIN
        -- Check for empty expression
        IF v_upper IS NULL OR LENGTH(v_upper) = 0 THEN
            RETURN FALSE;
        END IF;
        
        -- Reject dangerous SQL keywords (case-insensitive, word boundaries)
        -- These patterns check for keywords not preceded/followed by alphanumeric chars
        FOR i IN 1..12 LOOP
            CASE i
                WHEN 1 THEN v_dangerous_pattern := '(^|[^A-Z0-9_])SELECT($|[^A-Z0-9_])';
                WHEN 2 THEN v_dangerous_pattern := '(^|[^A-Z0-9_])INSERT($|[^A-Z0-9_])';
                WHEN 3 THEN v_dangerous_pattern := '(^|[^A-Z0-9_])UPDATE($|[^A-Z0-9_])';
                WHEN 4 THEN v_dangerous_pattern := '(^|[^A-Z0-9_])DELETE($|[^A-Z0-9_])';
                WHEN 5 THEN v_dangerous_pattern := '(^|[^A-Z0-9_])DROP($|[^A-Z0-9_])';
                WHEN 6 THEN v_dangerous_pattern := '(^|[^A-Z0-9_])CREATE($|[^A-Z0-9_])';
                WHEN 7 THEN v_dangerous_pattern := '(^|[^A-Z0-9_])ALTER($|[^A-Z0-9_])';
                WHEN 8 THEN v_dangerous_pattern := '(^|[^A-Z0-9_])EXEC($|[^A-Z0-9_])';
                WHEN 9 THEN v_dangerous_pattern := '(^|[^A-Z0-9_])EXECUTE($|[^A-Z0-9_])';
                WHEN 10 THEN v_dangerous_pattern := '(^|[^A-Z0-9_])TRUNCATE($|[^A-Z0-9_])';
                WHEN 11 THEN v_dangerous_pattern := '(^|[^A-Z0-9_])GRANT($|[^A-Z0-9_])';
                WHEN 12 THEN v_dangerous_pattern := '(^|[^A-Z0-9_])REVOKE($|[^A-Z0-9_])';
            END CASE;
            
            IF REGEXP_LIKE(v_upper, v_dangerous_pattern) THEN
                RETURN FALSE;
            END IF;
        END LOOP;
        
        -- Reject semicolons (statement terminator)
        IF INSTR(v_upper, ';') > 0 THEN
            RETURN FALSE;
        END IF;
        
        -- Reject comments
        IF INSTR(v_upper, '--') > 0 OR INSTR(v_upper, '/*') > 0 THEN
            RETURN FALSE;
        END IF;
        
        -- Only allow safe characters: alphanumerics, spaces, (), *, +, -, /, ., _, ,
        IF NOT REGEXP_LIKE(v_upper, '^[A-Z0-9_\s\(\)\*\+\-\/\.\,]+$') THEN
            RETURN FALSE;
        END IF;
        
        RETURN TRUE;
    END validate_aggregate_expr;
    
    PROCEDURE register_aggregate(
        p_parent_table VARCHAR2,
        p_child_table  VARCHAR2,
        p_agg_column   VARCHAR2,
        p_fk_column    VARCHAR2,
        p_expression   VARCHAR2
    ) IS
    BEGIN
        -- Validate expression before storing
        IF NOT validate_aggregate_expr(p_expression) THEN
            RAISE_APPLICATION_ERROR(-20001, 'Invalid aggregate expression: contains disallowed characters or keywords');
        END IF;
        
        -- Validate table and column identifiers
        IF NOT REGEXP_LIKE(p_parent_table, '^[A-Za-z_][A-Za-z0-9_]*$') THEN
            RAISE_APPLICATION_ERROR(-20001, 'Invalid parent table name');
        END IF;
        IF NOT REGEXP_LIKE(p_child_table, '^[A-Za-z_][A-Za-z0-9_]*$') THEN
            RAISE_APPLICATION_ERROR(-20001, 'Invalid child table name');
        END IF;
        IF NOT REGEXP_LIKE(p_agg_column, '^[A-Za-z_][A-Za-z0-9_]*$') THEN
            RAISE_APPLICATION_ERROR(-20001, 'Invalid aggregate column name');
        END IF;
        IF NOT REGEXP_LIKE(p_fk_column, '^[A-Za-z_][A-Za-z0-9_]*$') THEN
            RAISE_APPLICATION_ERROR(-20001, 'Invalid FK column name');
        END IF;
        
        MERGE INTO crud_allowed_aggregates t
        USING (SELECT UPPER(p_parent_table) AS parent_table, 
                      UPPER(p_child_table) AS child_table,
                      UPPER(p_agg_column) AS agg_column FROM dual) s
        ON (t.parent_table = s.parent_table AND t.child_table = s.child_table AND t.agg_column = s.agg_column)
        WHEN MATCHED THEN
            UPDATE SET 
                fk_column = UPPER(p_fk_column),
                expression = p_expression
        WHEN NOT MATCHED THEN
            INSERT (parent_table, child_table, agg_column, fk_column, expression)
            VALUES (UPPER(p_parent_table), UPPER(p_child_table), UPPER(p_agg_column), 
                    UPPER(p_fk_column), p_expression);
    END register_aggregate;
    
    PROCEDURE clear_cache IS
    BEGIN
        g_meta_cache.DELETE;
        g_config_cache.DELETE;
    END clear_cache;
    
END pkg_crud;
/

-- ============================================================================
-- GENERIC STORED PROCEDURES (Wrappers for Go)
-- These use pkg_crud internally for all operations
-- ============================================================================

-- Generic INSERT procedure
CREATE OR REPLACE PROCEDURE sp_generic_insert(
    p_table_name   IN  VARCHAR2,
    p_tenant_id    IN  VARCHAR2,
    p_columns      IN  t_column_values,
    p_created_by   IN  VARCHAR2 DEFAULT NULL,
    p_id           OUT NUMBER,
    p_success      OUT NUMBER,
    p_error_msg    OUT VARCHAR2
) AS
    v_result t_crud_result;
BEGIN
    v_result := pkg_crud.do_insert(p_table_name, p_tenant_id, p_columns, p_created_by);
    p_id := v_result.generated_id;
    p_success := v_result.success;
    p_error_msg := v_result.error_message;
END sp_generic_insert;
/

-- Generic UPDATE procedure
CREATE OR REPLACE PROCEDURE sp_generic_update(
    p_table_name   IN  VARCHAR2,
    p_tenant_id    IN  VARCHAR2,
    p_id           IN  NUMBER,
    p_columns      IN  t_column_values,
    p_updated_by   IN  VARCHAR2 DEFAULT NULL,
    p_rows         OUT NUMBER,
    p_success      OUT NUMBER,
    p_error_msg    OUT VARCHAR2
) AS
    v_result t_crud_result;
BEGIN
    v_result := pkg_crud.do_update(p_table_name, p_tenant_id, p_id, p_columns, p_updated_by);
    p_rows := v_result.rows_affected;
    p_success := v_result.success;
    p_error_msg := v_result.error_message;
END sp_generic_update;
/

-- Generic DELETE procedure
CREATE OR REPLACE PROCEDURE sp_generic_delete(
    p_table_name   IN  VARCHAR2,
    p_tenant_id    IN  VARCHAR2,
    p_id           IN  NUMBER,
    p_soft_delete  IN  NUMBER DEFAULT 1,
    p_deleted_by   IN  VARCHAR2 DEFAULT NULL,
    p_rows         OUT NUMBER,
    p_success      OUT NUMBER,
    p_error_msg    OUT VARCHAR2
) AS
    v_result t_crud_result;
BEGIN
    v_result := pkg_crud.do_delete(p_table_name, p_tenant_id, p_id, p_soft_delete = 1, p_deleted_by);
    p_rows := v_result.rows_affected;
    p_success := v_result.success;
    p_error_msg := v_result.error_message;
END sp_generic_delete;
/

-- Generic SELECT by ID
CREATE OR REPLACE PROCEDURE sp_generic_get(
    p_table_name   IN  VARCHAR2,
    p_tenant_id    IN  VARCHAR2,
    p_id           IN  NUMBER,
    p_columns      IN  VARCHAR2 DEFAULT NULL,
    p_cursor       OUT SYS_REFCURSOR
) AS
BEGIN
    p_cursor := pkg_crud.do_select(p_table_name, p_tenant_id, p_id, p_columns);
END sp_generic_get;
/

-- Generic SELECT with pagination
CREATE OR REPLACE PROCEDURE sp_generic_list(
    p_table_name   IN  VARCHAR2,
    p_tenant_id    IN  VARCHAR2,
    p_columns      IN  VARCHAR2 DEFAULT NULL,
    p_offset       IN  NUMBER DEFAULT 0,
    p_limit        IN  NUMBER DEFAULT 50,
    p_cursor       OUT SYS_REFCURSOR,
    p_total        OUT NUMBER
) AS
BEGIN
    -- Use single query that returns total_count as first column
    p_cursor := pkg_crud.do_query_with_total(p_table_name, p_tenant_id, p_columns, NULL, NULL, p_offset, p_limit);
    -- Total will be extracted from the first row's total_count column by the caller
    p_total := 0; -- Placeholder, actual total comes from cursor data
END sp_generic_list;
/

-- Generic aggregate update
CREATE OR REPLACE PROCEDURE sp_generic_aggregate(
    p_parent_table IN  VARCHAR2,
    p_parent_id    IN  NUMBER,
    p_tenant_id    IN  VARCHAR2,
    p_child_table  IN  VARCHAR2,
    p_success      OUT NUMBER,
    p_error_msg    OUT VARCHAR2
) AS
    v_result t_crud_result;
BEGIN
    v_result := pkg_crud.do_aggregate(p_parent_table, p_parent_id, p_tenant_id, p_child_table);
    p_success := v_result.success;
    p_error_msg := v_result.error_message;
END sp_generic_aggregate;
/

COMMIT;
