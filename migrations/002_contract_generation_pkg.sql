-- Migration: 002_contract_generation_pkg.sql
-- PL/SQL Package for Contract Document Generation
-- Returns clean JSON data structures - presentation handled by frontend

-- ============================================================================
-- SUPPORTING TABLES
-- ============================================================================

-- Contract templates (stores template metadata, not HTML)
CREATE TABLE contract_templates (
    id              NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    tenant_id       VARCHAR2(100) NOT NULL,
    template_code   VARCHAR2(50) NOT NULL,
    template_name   VARCHAR2(255) NOT NULL,
    language        VARCHAR2(5) DEFAULT 'pt-BR',
    
    -- Template sections (plain text, no HTML)
    intro_text          CLOB,
    payment_terms_text  CLOB,
    general_terms       CLOB,
    confidentiality     CLOB,
    termination_clause  CLOB,
    dispute_resolution  CLOB,
    
    is_default      NUMBER(1) DEFAULT 0 CHECK (is_default IN (0,1)),
    active          NUMBER(1) DEFAULT 1 CHECK (active IN (0,1)),
    version         NUMBER DEFAULT 1,
    
    created_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    created_by      VARCHAR2(100),
    updated_by      VARCHAR2(100),
    
    CONSTRAINT uk_template_tenant_code UNIQUE (tenant_id, template_code)
);

CREATE INDEX idx_templates_tenant ON contract_templates(tenant_id);

-- Ensure at most one default template per tenant
CREATE UNIQUE INDEX uk_template_default_tenant ON contract_templates(tenant_id)
    WHERE is_default = 1;

-- Generated contracts cache
CREATE TABLE generated_contracts (
    id                  NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    tenant_id           VARCHAR2(100) NOT NULL,
    contract_id         NUMBER NOT NULL,
    template_id         NUMBER,
    generation_number   NUMBER NOT NULL,
    
    -- JSON data (clean structure, no HTML)
    contract_json       CLOB NOT NULL CHECK (contract_json IS JSON),
    content_hash        VARCHAR2(64) NOT NULL,
    
    -- Snapshot metadata
    customer_name_snapshot  VARCHAR2(255) NOT NULL,
    total_value_snapshot    NUMBER(15,2) NOT NULL,
    services_count_snapshot NUMBER NOT NULL,
    
    generated_at        TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    generated_by        VARCHAR2(100) NOT NULL,
    generation_reason   VARCHAR2(100),
    expires_at          TIMESTAMP,
    
    CONSTRAINT fk_generated_contract FOREIGN KEY (tenant_id, contract_id)
        REFERENCES contracts(tenant_id, id) ON DELETE CASCADE,
    CONSTRAINT fk_generated_contract_template FOREIGN KEY (template_id)
        REFERENCES contract_templates(id) ON DELETE SET NULL,
    CONSTRAINT uk_generated_contract_gennum UNIQUE (tenant_id, contract_id, generation_number)
);

CREATE INDEX idx_generated_contract ON generated_contracts(tenant_id, contract_id);
CREATE INDEX idx_generated_hash ON generated_contracts(content_hash);

-- Audit log (privacy-aware)
CREATE TABLE contract_generation_log (
    id              NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    tenant_id       VARCHAR2(100) NOT NULL,
    contract_id     NUMBER NOT NULL,
    generated_id    NUMBER,
    action          VARCHAR2(30) NOT NULL,
    action_status   VARCHAR2(20) NOT NULL,
    performed_by    VARCHAR2(100) NOT NULL,
    performed_at    TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    ip_address_hash VARCHAR2(64),
    session_id_hash VARCHAR2(64),
    error_code      VARCHAR2(50),
    error_category  VARCHAR2(50),
    
    CONSTRAINT fk_gen_log_contract FOREIGN KEY (tenant_id, contract_id)
        REFERENCES contracts(tenant_id, id) ON DELETE CASCADE,
    CONSTRAINT fk_gen_log_generated FOREIGN KEY (generated_id)
        REFERENCES generated_contracts(id) ON DELETE SET NULL
);

CREATE INDEX idx_gen_log_tenant ON contract_generation_log(tenant_id, performed_at);

-- ============================================================================
-- TYPE SPECIFICATIONS - Clean Data Structures
-- ============================================================================

-- Address type
CREATE OR REPLACE TYPE t_address AS OBJECT (
    street      VARCHAR2(255),
    number_     VARCHAR2(20),
    complement  VARCHAR2(100),
    district    VARCHAR2(100),
    city        VARCHAR2(100),
    state       VARCHAR2(2),
    zip         VARCHAR2(10),
    country     VARCHAR2(50),
    
    -- Methods
    CONSTRUCTOR FUNCTION t_address RETURN SELF AS RESULT,
    MEMBER FUNCTION to_json RETURN JSON_OBJECT_T,
    MEMBER FUNCTION full_address RETURN VARCHAR2,
    MEMBER FUNCTION is_empty RETURN BOOLEAN
);
/

-- Address type body
CREATE OR REPLACE TYPE BODY t_address AS
    CONSTRUCTOR FUNCTION t_address RETURN SELF AS RESULT IS
    BEGIN
        SELF.country := 'BR';
        RETURN;
    END;
    
    MEMBER FUNCTION to_json RETURN JSON_OBJECT_T IS
        v_json JSON_OBJECT_T := JSON_OBJECT_T();
    BEGIN
        v_json.put('street', SELF.street);
        v_json.put('number', SELF.number_);
        v_json.put('complement', SELF.complement);
        v_json.put('district', SELF.district);
        v_json.put('city', SELF.city);
        v_json.put('state', SELF.state);
        v_json.put('zip', SELF.zip);
        v_json.put('country', SELF.country);
        RETURN v_json;
    END;
    
    MEMBER FUNCTION full_address RETURN VARCHAR2 IS
    BEGIN
        RETURN SELF.street || ', ' || SELF.number_ ||
               CASE WHEN SELF.complement IS NOT NULL THEN ', ' || SELF.complement ELSE '' END ||
               ' - ' || SELF.district || ', ' || SELF.city || '/' || SELF.state ||
               ' - CEP: ' || SELF.zip;
    END;
    
    MEMBER FUNCTION is_empty RETURN BOOLEAN IS
    BEGIN
        RETURN SELF.street IS NULL AND SELF.city IS NULL;
    END;
END;
/

-- Customer data type
CREATE OR REPLACE TYPE t_customer_data AS OBJECT (
    id              NUMBER,
    customer_code   VARCHAR2(50),
    customer_type   VARCHAR2(20),
    name            VARCHAR2(255),
    trade_name      VARCHAR2(255),
    tax_id          VARCHAR2(20),
    state_reg       VARCHAR2(30),
    municipal_reg   VARCHAR2(30),
    email           VARCHAR2(255),
    phone           VARCHAR2(20),
    mobile          VARCHAR2(20),
    address         t_address,
    
    -- Methods
    CONSTRUCTOR FUNCTION t_customer_data RETURN SELF AS RESULT,
    MEMBER FUNCTION to_json RETURN JSON_OBJECT_T,
    MEMBER FUNCTION display_name RETURN VARCHAR2,
    MEMBER FUNCTION formatted_tax_id RETURN VARCHAR2,
    MEMBER FUNCTION customer_type_label RETURN VARCHAR2
);
/

CREATE OR REPLACE TYPE BODY t_customer_data AS
    CONSTRUCTOR FUNCTION t_customer_data RETURN SELF AS RESULT IS
    BEGIN
        SELF.address := t_address();
        RETURN;
    END;
    
    MEMBER FUNCTION to_json RETURN JSON_OBJECT_T IS
        v_json JSON_OBJECT_T := JSON_OBJECT_T();
    BEGIN
        v_json.put('id', SELF.id);
        v_json.put('customer_code', SELF.customer_code);
        v_json.put('customer_type', SELF.customer_type);
        v_json.put('customer_type_label', SELF.customer_type_label());
        v_json.put('name', SELF.name);
        v_json.put('trade_name', SELF.trade_name);
        v_json.put('display_name', SELF.display_name());
        v_json.put('tax_id', SELF.tax_id);
        v_json.put('formatted_tax_id', SELF.formatted_tax_id());
        v_json.put('state_reg', SELF.state_reg);
        v_json.put('municipal_reg', SELF.municipal_reg);
        v_json.put('email', SELF.email);
        v_json.put('phone', SELF.phone);
        v_json.put('mobile', SELF.mobile);
        IF SELF.address IS NOT NULL THEN
            v_json.put('address', SELF.address.to_json());
        END IF;
        RETURN v_json;
    END;
    
    MEMBER FUNCTION display_name RETURN VARCHAR2 IS
    BEGIN
        RETURN NVL(SELF.trade_name, SELF.name);
    END;
    
    MEMBER FUNCTION formatted_tax_id RETURN VARCHAR2 IS
    BEGIN
        IF SELF.tax_id IS NULL THEN
            RETURN NULL;
        ELSIF LENGTH(REGEXP_REPLACE(SELF.tax_id, '[^0-9]', '')) = 11 THEN
            -- CPF: 000.000.000-00
            RETURN REGEXP_REPLACE(SELF.tax_id, '([0-9]{3})([0-9]{3})([0-9]{3})([0-9]{2})', '\1.\2.\3-\4');
        ELSIF LENGTH(REGEXP_REPLACE(SELF.tax_id, '[^0-9]', '')) = 14 THEN
            -- CNPJ: 00.000.000/0000-00
            RETURN REGEXP_REPLACE(SELF.tax_id, '([0-9]{2})([0-9]{3})([0-9]{3})([0-9]{4})([0-9]{2})', '\1.\2.\3/\4-\5');
        ELSE
            RETURN SELF.tax_id;
        END IF;
    END;
    
    MEMBER FUNCTION customer_type_label RETURN VARCHAR2 IS
    BEGIN
        RETURN CASE SELF.customer_type 
            WHEN 'COMPANY' THEN 'Pessoa Jurídica'
            WHEN 'INDIVIDUAL' THEN 'Pessoa Física'
            ELSE SELF.customer_type
        END;
    END;
END;
/

-- Service line item type
CREATE OR REPLACE TYPE t_service_item AS OBJECT (
    id              NUMBER,
    service_id      NUMBER,
    service_code    VARCHAR2(50),
    service_name    VARCHAR2(255),
    description     VARCHAR2(4000),
    quantity        NUMBER(10,2),
    unit_price      NUMBER(15,2),
    discount_pct    NUMBER(5,2),
    line_total      NUMBER(15,2),
    price_unit      VARCHAR2(20),
    status          VARCHAR2(20),
    
    -- Methods
    MEMBER FUNCTION to_json RETURN JSON_OBJECT_T,
    MEMBER FUNCTION price_unit_label RETURN VARCHAR2,
    MEMBER FUNCTION formatted_unit_price RETURN VARCHAR2,
    MEMBER FUNCTION formatted_line_total RETURN VARCHAR2,
    MEMBER FUNCTION discount_amount RETURN NUMBER
);
/

CREATE OR REPLACE TYPE BODY t_service_item AS
    MEMBER FUNCTION to_json RETURN JSON_OBJECT_T IS
        v_json JSON_OBJECT_T := JSON_OBJECT_T();
    BEGIN
        v_json.put('id', SELF.id);
        v_json.put('service_id', SELF.service_id);
        v_json.put('service_code', SELF.service_code);
        v_json.put('service_name', SELF.service_name);
        v_json.put('description', SELF.description);
        v_json.put('quantity', SELF.quantity);
        v_json.put('unit_price', SELF.unit_price);
        v_json.put('formatted_unit_price', SELF.formatted_unit_price());
        v_json.put('discount_pct', SELF.discount_pct);
        v_json.put('discount_amount', SELF.discount_amount());
        v_json.put('line_total', SELF.line_total);
        v_json.put('formatted_line_total', SELF.formatted_line_total());
        v_json.put('price_unit', SELF.price_unit);
        v_json.put('price_unit_label', SELF.price_unit_label());
        v_json.put('status', SELF.status);
        RETURN v_json;
    END;
    
    MEMBER FUNCTION price_unit_label RETURN VARCHAR2 IS
    BEGIN
        RETURN CASE SELF.price_unit
            WHEN 'HOUR' THEN 'por hora'
            WHEN 'DAY' THEN 'por dia'
            WHEN 'MONTH' THEN 'por mês'
            WHEN 'PROJECT' THEN 'por projeto'
            WHEN 'UNIT' THEN 'por unidade'
            ELSE SELF.price_unit
        END;
    END;
    
    MEMBER FUNCTION formatted_unit_price RETURN VARCHAR2 IS
    BEGIN
        RETURN 'R$ ' || TO_CHAR(SELF.unit_price, 'FM999G999G999D00', 'NLS_NUMERIC_CHARACTERS='',.''');
    END;
    
    MEMBER FUNCTION formatted_line_total RETURN VARCHAR2 IS
    BEGIN
        RETURN 'R$ ' || TO_CHAR(SELF.line_total, 'FM999G999G999D00', 'NLS_NUMERIC_CHARACTERS='',.''');
    END;
    
    MEMBER FUNCTION discount_amount RETURN NUMBER IS
    BEGIN
        RETURN NVL(SELF.quantity, 0) * NVL(SELF.unit_price, 0) * (NVL(SELF.discount_pct, 0) / 100);
    END;
END;
/

-- Collection of service items
CREATE OR REPLACE TYPE t_service_items AS TABLE OF t_service_item;
/

-- Contract data type
CREATE OR REPLACE TYPE t_contract_data AS OBJECT (
    id              NUMBER,
    contract_number VARCHAR2(50),
    contract_type   VARCHAR2(30),
    status          VARCHAR2(20),
    start_date      DATE,
    end_date        DATE,
    duration_months NUMBER,
    auto_renew      NUMBER(1),
    total_value     NUMBER(15,2),
    payment_terms   VARCHAR2(100),
    billing_cycle   VARCHAR2(20),
    signed_at       TIMESTAMP,
    signed_by       VARCHAR2(100),
    notes           CLOB,
    terms_conditions CLOB,
    created_at      TIMESTAMP,
    
    -- Methods
    MEMBER FUNCTION to_json RETURN JSON_OBJECT_T,
    MEMBER FUNCTION contract_type_label RETURN VARCHAR2,
    MEMBER FUNCTION status_label RETURN VARCHAR2,
    MEMBER FUNCTION billing_cycle_label RETURN VARCHAR2,
    MEMBER FUNCTION formatted_total_value RETURN VARCHAR2,
    MEMBER FUNCTION formatted_start_date RETURN VARCHAR2,
    MEMBER FUNCTION formatted_end_date RETURN VARCHAR2,
    MEMBER FUNCTION is_active RETURN BOOLEAN
);
/

CREATE OR REPLACE TYPE BODY t_contract_data AS
    MEMBER FUNCTION to_json RETURN JSON_OBJECT_T IS
        v_json JSON_OBJECT_T := JSON_OBJECT_T();
    BEGIN
        v_json.put('id', SELF.id);
        v_json.put('contract_number', SELF.contract_number);
        v_json.put('contract_type', SELF.contract_type);
        v_json.put('contract_type_label', SELF.contract_type_label());
        v_json.put('status', SELF.status);
        v_json.put('status_label', SELF.status_label());
        v_json.put('start_date', TO_CHAR(SELF.start_date, 'YYYY-MM-DD'));
        v_json.put('formatted_start_date', SELF.formatted_start_date());
        v_json.put('end_date', TO_CHAR(SELF.end_date, 'YYYY-MM-DD'));
        v_json.put('formatted_end_date', SELF.formatted_end_date());
        v_json.put('duration_months', SELF.duration_months);
        v_json.put('auto_renew', CASE SELF.auto_renew WHEN 1 THEN TRUE ELSE FALSE END);
        v_json.put('total_value', SELF.total_value);
        v_json.put('formatted_total_value', SELF.formatted_total_value());
        v_json.put('payment_terms', SELF.payment_terms);
        v_json.put('billing_cycle', SELF.billing_cycle);
        v_json.put('billing_cycle_label', SELF.billing_cycle_label());
        v_json.put('signed_at', TO_CHAR(SELF.signed_at, 'YYYY-MM-DD"T"HH24:MI:SS'));
        v_json.put('signed_by', SELF.signed_by);
        v_json.put('notes', SELF.notes);
        v_json.put('terms_conditions', SELF.terms_conditions);
        v_json.put('created_at', TO_CHAR(SELF.created_at, 'YYYY-MM-DD"T"HH24:MI:SS'));
        RETURN v_json;
    END;
    
    MEMBER FUNCTION contract_type_label RETURN VARCHAR2 IS
    BEGIN
        RETURN CASE SELF.contract_type
            WHEN 'SERVICE' THEN 'Prestação de Serviços'
            WHEN 'RECURRING' THEN 'Recorrente'
            WHEN 'PROJECT' THEN 'Projeto'
            ELSE SELF.contract_type
        END;
    END;
    
    MEMBER FUNCTION status_label RETURN VARCHAR2 IS
    BEGIN
        RETURN CASE SELF.status
            WHEN 'DRAFT' THEN 'Rascunho'
            WHEN 'PENDING' THEN 'Pendente'
            WHEN 'ACTIVE' THEN 'Ativo'
            WHEN 'SUSPENDED' THEN 'Suspenso'
            WHEN 'CANCELLED' THEN 'Cancelado'
            WHEN 'COMPLETED' THEN 'Concluído'
            ELSE SELF.status
        END;
    END;
    
    MEMBER FUNCTION billing_cycle_label RETURN VARCHAR2 IS
    BEGIN
        RETURN CASE SELF.billing_cycle
            WHEN 'MONTHLY' THEN 'Mensal'
            WHEN 'QUARTERLY' THEN 'Trimestral'
            WHEN 'YEARLY' THEN 'Anual'
            WHEN 'ONCE' THEN 'Pagamento Único'
            ELSE SELF.billing_cycle
        END;
    END;
    
    MEMBER FUNCTION formatted_total_value RETURN VARCHAR2 IS
    BEGIN
        RETURN 'R$ ' || TO_CHAR(SELF.total_value, 'FM999G999G999D00', 'NLS_NUMERIC_CHARACTERS='',.''');
    END;
    
    MEMBER FUNCTION formatted_start_date RETURN VARCHAR2 IS
    BEGIN
        RETURN TO_CHAR(SELF.start_date, 'DD "de" TMMonth "de" YYYY', 'NLS_DATE_LANGUAGE=PORTUGUESE');
    END;
    
    MEMBER FUNCTION formatted_end_date RETURN VARCHAR2 IS
    BEGIN
        IF SELF.end_date IS NULL THEN
            RETURN NULL;
        END IF;
        RETURN TO_CHAR(SELF.end_date, 'DD "de" TMMonth "de" YYYY', 'NLS_DATE_LANGUAGE=PORTUGUESE');
    END;
    
    MEMBER FUNCTION is_active RETURN BOOLEAN IS
    BEGIN
        RETURN SELF.status = 'ACTIVE';
    END;
END;
/

-- Template data type
CREATE OR REPLACE TYPE t_template_data AS OBJECT (
    id                  NUMBER,
    template_code       VARCHAR2(50),
    template_name       VARCHAR2(255),
    language            VARCHAR2(5),
    intro_text          CLOB,
    payment_terms_text  CLOB,
    general_terms       CLOB,
    confidentiality     CLOB,
    termination_clause  CLOB,
    dispute_resolution  CLOB,
    
    MEMBER FUNCTION to_json RETURN JSON_OBJECT_T
);
/

CREATE OR REPLACE TYPE BODY t_template_data AS
    MEMBER FUNCTION to_json RETURN JSON_OBJECT_T IS
        v_json JSON_OBJECT_T := JSON_OBJECT_T();
    BEGIN
        v_json.put('id', SELF.id);
        v_json.put('template_code', SELF.template_code);
        v_json.put('template_name', SELF.template_name);
        v_json.put('language', SELF.language);
        v_json.put('intro_text', SELF.intro_text);
        v_json.put('payment_terms_text', SELF.payment_terms_text);
        v_json.put('general_terms', SELF.general_terms);
        v_json.put('confidentiality', SELF.confidentiality);
        v_json.put('termination_clause', SELF.termination_clause);
        v_json.put('dispute_resolution', SELF.dispute_resolution);
        RETURN v_json;
    END;
END;
/

-- Generation result type
CREATE OR REPLACE TYPE t_gen_result AS OBJECT (
    success         NUMBER(1),
    generated_id    NUMBER,
    content_hash    VARCHAR2(64),
    error_code      VARCHAR2(50),
    error_message   VARCHAR2(4000),
    
    STATIC FUNCTION ok(p_generated_id NUMBER, p_hash VARCHAR2) RETURN t_gen_result,
    STATIC FUNCTION err(p_code VARCHAR2, p_message VARCHAR2) RETURN t_gen_result,
    MEMBER FUNCTION to_json RETURN JSON_OBJECT_T
);
/

CREATE OR REPLACE TYPE BODY t_gen_result AS
    STATIC FUNCTION ok(p_generated_id NUMBER, p_hash VARCHAR2) RETURN t_gen_result IS
    BEGIN
        RETURN t_gen_result(1, p_generated_id, p_hash, NULL, NULL);
    END;
    
    STATIC FUNCTION err(p_code VARCHAR2, p_message VARCHAR2) RETURN t_gen_result IS
    BEGIN
        RETURN t_gen_result(0, NULL, NULL, p_code, p_message);
    END;
    
    MEMBER FUNCTION to_json RETURN JSON_OBJECT_T IS
        v_json JSON_OBJECT_T := JSON_OBJECT_T();
    BEGIN
        v_json.put('success', CASE SELF.success WHEN 1 THEN TRUE ELSE FALSE END);
        v_json.put('generated_id', SELF.generated_id);
        v_json.put('content_hash', SELF.content_hash);
        v_json.put('error_code', SELF.error_code);
        v_json.put('error_message', SELF.error_message);
        RETURN v_json;
    END;
END;
/

-- ============================================================================
-- DYNAMIC CRUD API PACKAGE
-- ============================================================================
CREATE OR REPLACE PACKAGE pkg_data_api AS
    /*
    ============================================================================
    DATA API PACKAGE
    ============================================================================
    Provides dynamic, tenant-aware data loading operations.
    Abstracts direct table access for security and maintainability.
    ============================================================================
    */
    
    -- Entity types
    gc_entity_customer  CONSTANT VARCHAR2(30) := 'CUSTOMER';
    gc_entity_service   CONSTANT VARCHAR2(30) := 'SERVICE';
    gc_entity_contract  CONSTANT VARCHAR2(30) := 'CONTRACT';
    
    -- Load customer data into type
    FUNCTION load_customer(
        p_tenant_id   IN VARCHAR2,
        p_customer_id IN NUMBER
    ) RETURN t_customer_data;
    
    -- Load contract data into type
    FUNCTION load_contract(
        p_tenant_id   IN VARCHAR2,
        p_contract_id IN NUMBER
    ) RETURN t_contract_data;
    
    -- Load contract items into collection
    FUNCTION load_contract_items(
        p_tenant_id   IN VARCHAR2,
        p_contract_id IN NUMBER
    ) RETURN t_service_items;
    
    -- Load template data
    FUNCTION load_template(
        p_tenant_id     IN VARCHAR2,
        p_template_code IN VARCHAR2 DEFAULT NULL
    ) RETURN t_template_data;
    
    -- Get entity as JSON by ID
    FUNCTION get_entity_json(
        p_tenant_id   IN VARCHAR2,
        p_entity_type IN VARCHAR2,
        p_entity_id   IN NUMBER
    ) RETURN CLOB;
    
    -- Check entity exists
    FUNCTION entity_exists(
        p_tenant_id   IN VARCHAR2,
        p_entity_type IN VARCHAR2,
        p_entity_id   IN NUMBER
    ) RETURN BOOLEAN;
    
    -- Hash utilities
    FUNCTION hash_sha256(p_value IN VARCHAR2) RETURN VARCHAR2;
    FUNCTION hash_clob_sha256(p_value IN CLOB) RETURN VARCHAR2;

END pkg_data_api;
/

CREATE OR REPLACE PACKAGE BODY pkg_data_api AS

    FUNCTION hash_sha256(p_value IN VARCHAR2) RETURN VARCHAR2 IS
    BEGIN
        IF p_value IS NULL THEN
            RETURN NULL;
        END IF;
        RETURN LOWER(RAWTOHEX(DBMS_CRYPTO.HASH(
            UTL_I18N.STRING_TO_RAW(p_value, 'AL32UTF8'),
            DBMS_CRYPTO.HASH_SH256
        )));
    END;
    
    FUNCTION hash_clob_sha256(p_value IN CLOB) RETURN VARCHAR2 IS
    BEGIN
        IF p_value IS NULL OR DBMS_LOB.GETLENGTH(p_value) = 0 THEN
            RETURN NULL;
        END IF;
        RETURN LOWER(RAWTOHEX(DBMS_CRYPTO.HASH(p_value, DBMS_CRYPTO.HASH_SH256)));
    END;

    FUNCTION load_customer(
        p_tenant_id   IN VARCHAR2,
        p_customer_id IN NUMBER
    ) RETURN t_customer_data IS
        v_cust t_customer_data;
    BEGIN
        SELECT t_customer_data(
            id              => c.id,
            customer_code   => c.customer_code,
            customer_type   => c.customer_type,
            name            => c.name,
            trade_name      => c.trade_name,
            tax_id          => c.tax_id,
            state_reg       => c.state_reg,
            municipal_reg   => c.municipal_reg,
            email           => c.email,
            phone           => c.phone,
            mobile          => c.mobile,
            address         => t_address(
                street      => c.address_street,
                number_     => c.address_number,
                complement  => c.address_comp,
                district    => c.address_district,
                city        => c.address_city,
                state       => c.address_state,
                zip         => c.address_zip,
                country     => c.address_country
            )
        )
        INTO v_cust
        FROM customers c
        WHERE c.tenant_id = p_tenant_id
          AND c.id = p_customer_id;
        
        RETURN v_cust;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN NULL;
    END;
    
    FUNCTION load_contract(
        p_tenant_id   IN VARCHAR2,
        p_contract_id IN NUMBER
    ) RETURN t_contract_data IS
        v_contract t_contract_data;
    BEGIN
        SELECT t_contract_data(
            id              => c.id,
            contract_number => c.contract_number,
            contract_type   => c.contract_type,
            status          => c.status,
            start_date      => c.start_date,
            end_date        => c.end_date,
            duration_months => c.duration_months,
            auto_renew      => c.auto_renew,
            total_value     => c.total_value,
            payment_terms   => c.payment_terms,
            billing_cycle   => c.billing_cycle,
            signed_at       => c.signed_at,
            signed_by       => c.signed_by,
            notes           => c.notes,
            terms_conditions => c.terms_conditions,
            created_at      => c.created_at
        )
        INTO v_contract
        FROM contracts c
        WHERE c.tenant_id = p_tenant_id
          AND c.id = p_contract_id;
        
        RETURN v_contract;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN NULL;
    END;
    
    FUNCTION load_contract_items(
        p_tenant_id   IN VARCHAR2,
        p_contract_id IN NUMBER
    ) RETURN t_service_items IS
        v_items t_service_items := t_service_items();
    BEGIN
        SELECT t_service_item(
            id           => ci.id,
            service_id   => ci.service_id,
            service_code => s.service_code,
            service_name => s.name,
            description  => NVL(ci.description, s.description),
            quantity     => ci.quantity,
            unit_price   => ci.unit_price,
            discount_pct => ci.discount_pct,
            line_total   => ci.line_total,
            price_unit   => s.price_unit,
            status       => ci.status
        )
        BULK COLLECT INTO v_items
        FROM contract_items ci
        JOIN services s ON s.tenant_id = ci.tenant_id AND s.id = ci.service_id
        WHERE ci.tenant_id = p_tenant_id
          AND ci.contract_id = p_contract_id
          AND ci.status != 'CANCELLED'
        ORDER BY ci.id;
        
        RETURN v_items;
    END;
    
    FUNCTION load_template(
        p_tenant_id     IN VARCHAR2,
        p_template_code IN VARCHAR2 DEFAULT NULL
    ) RETURN t_template_data IS
        v_template t_template_data;
    BEGIN
        IF p_template_code IS NOT NULL THEN
            SELECT t_template_data(
                id                 => t.id,
                template_code      => t.template_code,
                template_name      => t.template_name,
                language           => t.language,
                intro_text         => t.intro_text,
                payment_terms_text => t.payment_terms_text,
                general_terms      => t.general_terms,
                confidentiality    => t.confidentiality,
                termination_clause => t.termination_clause,
                dispute_resolution => t.dispute_resolution
            )
            INTO v_template
            FROM contract_templates t
            WHERE t.tenant_id = p_tenant_id
              AND t.template_code = p_template_code
              AND t.active = 1;
        ELSE
            SELECT t_template_data(
                id                 => t.id,
                template_code      => t.template_code,
                template_name      => t.template_name,
                language           => t.language,
                intro_text         => t.intro_text,
                payment_terms_text => t.payment_terms_text,
                general_terms      => t.general_terms,
                confidentiality    => t.confidentiality,
                termination_clause => t.termination_clause,
                dispute_resolution => t.dispute_resolution
            )
            INTO v_template
            FROM contract_templates t
            WHERE t.tenant_id = p_tenant_id
              AND t.is_default = 1
              AND t.active = 1
            ORDER BY t.id DESC
            FETCH FIRST 1 ROW ONLY;
        END IF;
        
        RETURN v_template;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN NULL;
    END;
    
    FUNCTION get_entity_json(
        p_tenant_id   IN VARCHAR2,
        p_entity_type IN VARCHAR2,
        p_entity_id   IN NUMBER
    ) RETURN CLOB IS
        v_result CLOB;
    BEGIN
        CASE UPPER(p_entity_type)
            WHEN gc_entity_customer THEN
                SELECT JSON_OBJECT(
                    'id' VALUE id,
                    'customer_code' VALUE customer_code,
                    'customer_type' VALUE customer_type,
                    'name' VALUE name,
                    'trade_name' VALUE trade_name,
                    'tax_id' VALUE tax_id,
                    'email' VALUE email,
                    'phone' VALUE phone,
                    'active' VALUE CASE active WHEN 1 THEN 'true' ELSE 'false' END FORMAT JSON
                    RETURNING CLOB
                )
                INTO v_result
                FROM customers
                WHERE tenant_id = p_tenant_id AND id = p_entity_id;
                
            WHEN gc_entity_service THEN
                SELECT JSON_OBJECT(
                    'id' VALUE id,
                    'service_code' VALUE service_code,
                    'name' VALUE name,
                    'description' VALUE description,
                    'category' VALUE category,
                    'unit_price' VALUE unit_price,
                    'price_unit' VALUE price_unit,
                    'active' VALUE CASE active WHEN 1 THEN 'true' ELSE 'false' END FORMAT JSON
                    RETURNING CLOB
                )
                INTO v_result
                FROM services
                WHERE tenant_id = p_tenant_id AND id = p_entity_id;
                
            WHEN gc_entity_contract THEN
                SELECT JSON_OBJECT(
                    'id' VALUE id,
                    'contract_number' VALUE contract_number,
                    'contract_type' VALUE contract_type,
                    'customer_id' VALUE customer_id,
                    'status' VALUE status,
                    'start_date' VALUE TO_CHAR(start_date, 'YYYY-MM-DD'),
                    'end_date' VALUE TO_CHAR(end_date, 'YYYY-MM-DD'),
                    'total_value' VALUE total_value,
                    'billing_cycle' VALUE billing_cycle
                    RETURNING CLOB
                )
                INTO v_result
                FROM contracts
                WHERE tenant_id = p_tenant_id AND id = p_entity_id;
                
            ELSE
                RAISE_APPLICATION_ERROR(-20001, 'Unknown entity type: ' || p_entity_type);
        END CASE;
        
        RETURN v_result;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN NULL;
    END;
    
    FUNCTION entity_exists(
        p_tenant_id   IN VARCHAR2,
        p_entity_type IN VARCHAR2,
        p_entity_id   IN NUMBER
    ) RETURN BOOLEAN IS
        v_count NUMBER;
    BEGIN
        CASE UPPER(p_entity_type)
            WHEN gc_entity_customer THEN
                SELECT COUNT(*) INTO v_count FROM customers 
                WHERE tenant_id = p_tenant_id AND id = p_entity_id;
            WHEN gc_entity_service THEN
                SELECT COUNT(*) INTO v_count FROM services 
                WHERE tenant_id = p_tenant_id AND id = p_entity_id;
            WHEN gc_entity_contract THEN
                SELECT COUNT(*) INTO v_count FROM contracts 
                WHERE tenant_id = p_tenant_id AND id = p_entity_id;
            ELSE
                RETURN FALSE;
        END CASE;
        
        RETURN v_count > 0;
    END;

END pkg_data_api;
/

-- ============================================================================
-- CONTRACT GENERATION PACKAGE - Returns Clean JSON
-- ============================================================================
CREATE OR REPLACE PACKAGE pkg_contract_generation AS
    /*
    ============================================================================
    CONTRACT GENERATION PACKAGE
    ============================================================================
    Generates contract data as clean JSON for PDF rendering by frontend.
    All sensitive processing happens here - backend is just a pass-through.
    ============================================================================
    */
    
    -- Error codes
    gc_err_contract_notfound CONSTANT VARCHAR2(30) := 'ERR_CONTRACT_NOT_FOUND';
    gc_err_template_notfound CONSTANT VARCHAR2(30) := 'ERR_TEMPLATE_NOT_FOUND';
    gc_err_customer_notfound CONSTANT VARCHAR2(30) := 'ERR_CUSTOMER_NOT_FOUND';
    gc_err_no_items          CONSTANT VARCHAR2(30) := 'ERR_NO_CONTRACT_ITEMS';
    gc_err_generation_failed CONSTANT VARCHAR2(30) := 'ERR_GENERATION_FAILED';
    
    -- Generate contract and return JSON data
    PROCEDURE generate_contract(
        p_tenant_id     IN  VARCHAR2,
        p_contract_id   IN  NUMBER,
        p_user_id       IN  VARCHAR2,
        p_template_code IN  VARCHAR2 DEFAULT NULL,
        p_reason        IN  VARCHAR2 DEFAULT 'INITIAL',
        p_ip_address    IN  VARCHAR2 DEFAULT NULL,
        p_session_id    IN  VARCHAR2 DEFAULT NULL,
        p_result        OUT t_gen_result,
        p_contract_json OUT CLOB
    );
    
    -- Get contract data as JSON (without caching)
    FUNCTION get_contract_json(
        p_tenant_id     IN VARCHAR2,
        p_contract_id   IN NUMBER,
        p_template_code IN VARCHAR2 DEFAULT NULL
    ) RETURN CLOB;
    
    -- Get cached generated contract
    PROCEDURE get_generated(
        p_tenant_id    IN  VARCHAR2,
        p_generated_id IN  NUMBER,
        p_user_id      IN  VARCHAR2,
        p_json_data    OUT CLOB,
        p_content_hash OUT VARCHAR2,
        p_generated_at OUT TIMESTAMP,
        p_success      OUT NUMBER,
        p_error_code   OUT VARCHAR2
    );
    
    -- Get latest generated for contract
    PROCEDURE get_latest_generated(
        p_tenant_id    IN  VARCHAR2,
        p_contract_id  IN  NUMBER,
        p_user_id      IN  VARCHAR2,
        p_json_data    OUT CLOB,
        p_content_hash OUT VARCHAR2,
        p_gen_id       OUT NUMBER,
        p_gen_at       OUT TIMESTAMP,
        p_success      OUT NUMBER,
        p_error_code   OUT VARCHAR2
    );
    
    -- Log action
    PROCEDURE log_action(
        p_tenant_id    IN VARCHAR2,
        p_contract_id  IN NUMBER,
        p_generated_id IN NUMBER   DEFAULT NULL,
        p_action       IN VARCHAR2,
        p_user_id      IN VARCHAR2,
        p_ip_address   IN VARCHAR2 DEFAULT NULL,
        p_session_id   IN VARCHAR2 DEFAULT NULL,
        p_status       IN VARCHAR2 DEFAULT 'SUCCESS',
        p_error_code   IN VARCHAR2 DEFAULT NULL
    );
    
    -- Initialize default template
    PROCEDURE init_default_template(
        p_tenant_id IN VARCHAR2,
        p_user_id   IN VARCHAR2
    );
    
    -- Verify integrity
    FUNCTION verify_integrity(p_generated_id IN NUMBER) RETURN NUMBER;
    
    -- Get stats
    PROCEDURE get_stats(
        p_tenant_id   IN  VARCHAR2,
        p_total       OUT NUMBER,
        p_today       OUT NUMBER,
        p_month       OUT NUMBER,
        p_unique      OUT NUMBER
    );

END pkg_contract_generation;
/

CREATE OR REPLACE PACKAGE BODY pkg_contract_generation AS

    -- Build the complete JSON structure for a contract
    FUNCTION build_contract_json(
        p_tenant_id     IN VARCHAR2,
        p_contract_id   IN NUMBER,
        p_template_code IN VARCHAR2
    ) RETURN CLOB IS
        v_contract  t_contract_data;
        v_customer  t_customer_data;
        v_template  t_template_data;
        v_items     t_service_items;
        
        v_root      JSON_OBJECT_T := JSON_OBJECT_T();
        v_meta      JSON_OBJECT_T := JSON_OBJECT_T();
        v_items_arr JSON_ARRAY_T := JSON_ARRAY_T();
    BEGIN
        -- Load all data using the API
        v_contract := pkg_data_api.load_contract(p_tenant_id, p_contract_id);
        IF v_contract IS NULL THEN
            RAISE_APPLICATION_ERROR(-20001, gc_err_contract_notfound);
        END IF;
        
        -- Get customer from contract
        DECLARE
            v_customer_id NUMBER;
        BEGIN
            SELECT customer_id INTO v_customer_id
            FROM contracts WHERE tenant_id = p_tenant_id AND id = p_contract_id;
            v_customer := pkg_data_api.load_customer(p_tenant_id, v_customer_id);
        END;
        
        IF v_customer IS NULL THEN
            RAISE_APPLICATION_ERROR(-20002, gc_err_customer_notfound);
        END IF;
        
        v_items := pkg_data_api.load_contract_items(p_tenant_id, p_contract_id);
        IF v_items IS NULL OR v_items.COUNT = 0 THEN
            RAISE_APPLICATION_ERROR(-20003, gc_err_no_items);
        END IF;
        
        v_template := pkg_data_api.load_template(p_tenant_id, p_template_code);
        
        -- Build metadata
        v_meta.put('generated_at', TO_CHAR(SYSTIMESTAMP, 'YYYY-MM-DD"T"HH24:MI:SS.FF3TZH:TZM'));
        v_meta.put('generated_date_formatted', TO_CHAR(SYSDATE, 'DD "de" TMMonth "de" YYYY', 'NLS_DATE_LANGUAGE=PORTUGUESE'));
        v_meta.put('template_code', CASE WHEN v_template IS NOT NULL THEN v_template.template_code ELSE 'NONE' END);
        v_meta.put('template_name', CASE WHEN v_template IS NOT NULL THEN v_template.template_name ELSE NULL END);
        v_meta.put('version', '1.0');
        
        -- Build items array
        FOR i IN 1..v_items.COUNT LOOP
            v_items_arr.append(v_items(i).to_json());
        END LOOP;
        
        -- Assemble root object
        v_root.put('meta', v_meta);
        v_root.put('contract', v_contract.to_json());
        v_root.put('customer', v_customer.to_json());
        v_root.put('items', v_items_arr);
        v_root.put('items_count', v_items.COUNT);
        
        -- Add template text if available
        IF v_template IS NOT NULL THEN
            v_root.put('template', v_template.to_json());
        END IF;
        
        -- Summary section
        DECLARE
            v_summary JSON_OBJECT_T := JSON_OBJECT_T();
            v_subtotal NUMBER := 0;
            v_discount NUMBER := 0;
        BEGIN
            FOR i IN 1..v_items.COUNT LOOP
                v_subtotal := v_subtotal + (NVL(v_items(i).quantity, 0) * NVL(v_items(i).unit_price, 0));
                v_discount := v_discount + v_items(i).discount_amount();
            END LOOP;
            
            v_summary.put('subtotal', v_subtotal);
            v_summary.put('formatted_subtotal', 'R$ ' || TO_CHAR(v_subtotal, 'FM999G999G999D00', 'NLS_NUMERIC_CHARACTERS='',.'''));
            v_summary.put('total_discount', v_discount);
            v_summary.put('formatted_total_discount', 'R$ ' || TO_CHAR(v_discount, 'FM999G999G999D00', 'NLS_NUMERIC_CHARACTERS='',.'''));
            v_summary.put('total', v_contract.total_value);
            v_summary.put('formatted_total', v_contract.formatted_total_value());
            
            v_root.put('summary', v_summary);
        END;
        
        RETURN v_root.to_clob();
    END;

    FUNCTION get_contract_json(
        p_tenant_id     IN VARCHAR2,
        p_contract_id   IN NUMBER,
        p_template_code IN VARCHAR2 DEFAULT NULL
    ) RETURN CLOB IS
    BEGIN
        RETURN build_contract_json(p_tenant_id, p_contract_id, p_template_code);
    END;

    PROCEDURE generate_contract(
        p_tenant_id     IN  VARCHAR2,
        p_contract_id   IN  NUMBER,
        p_user_id       IN  VARCHAR2,
        p_template_code IN  VARCHAR2 DEFAULT NULL,
        p_reason        IN  VARCHAR2 DEFAULT 'INITIAL',
        p_ip_address    IN  VARCHAR2 DEFAULT NULL,
        p_session_id    IN  VARCHAR2 DEFAULT NULL,
        p_result        OUT t_gen_result,
        p_contract_json OUT CLOB
    ) IS
        v_json          CLOB;
        v_hash          VARCHAR2(64);
        v_gen_id        NUMBER;
        v_gen_num       NUMBER;
        v_customer_name VARCHAR2(255);
        v_total_value   NUMBER;
        v_items_count   NUMBER;
        v_template_id   NUMBER;
    BEGIN
        -- Validate contract exists
        IF NOT pkg_data_api.entity_exists(p_tenant_id, 'CONTRACT', p_contract_id) THEN
            p_result := t_gen_result.err(gc_err_contract_notfound, 'Contract not found');
            p_contract_json := NULL;
            -- Do NOT call log_action here: contract doesn't exist, FK would fail
            RETURN;
        END IF;
        
        -- Build JSON
        BEGIN
            v_json := build_contract_json(p_tenant_id, p_contract_id, p_template_code);
        EXCEPTION
            WHEN OTHERS THEN
                p_result := t_gen_result.err(gc_err_generation_failed, SQLERRM);
                p_contract_json := NULL;
                log_action(p_tenant_id, p_contract_id, 'GENERATE', p_user_id, p_ip_address, p_session_id, 'FAILED', gc_err_generation_failed);
                RETURN;
        END;
        
        v_hash := pkg_data_api.hash_clob_sha256(v_json);
        
        -- Get snapshot data
        SELECT c.name, con.total_value
        INTO v_customer_name, v_total_value
        FROM contracts con
        JOIN customers c ON c.tenant_id = con.tenant_id AND c.id = con.customer_id
        WHERE con.id = p_contract_id AND con.tenant_id = p_tenant_id;
        
        SELECT COUNT(*) INTO v_items_count
        FROM contract_items
        WHERE contract_id = p_contract_id AND tenant_id = p_tenant_id AND status != 'CANCELLED';
        
        -- Get template ID if specified
        BEGIN
            IF p_template_code IS NOT NULL THEN
                SELECT id INTO v_template_id FROM contract_templates
                WHERE tenant_id = p_tenant_id AND template_code = p_template_code AND active = 1;
            ELSE
                SELECT id INTO v_template_id FROM contract_templates
                WHERE tenant_id = p_tenant_id AND is_default = 1 AND active = 1
                FETCH FIRST 1 ROW ONLY;
            END IF;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                v_template_id := NULL;
        END;
        
        -- Get next generation number with retry logic for race condition
        -- Uses unique constraint uk_generated_contract_gennum as guard
        DECLARE
            v_retry_count NUMBER := 0;
            gc_max_retries CONSTANT NUMBER := 5;
        BEGIN
            LOOP
                SELECT NVL(MAX(generation_number), 0) + 1
                INTO v_gen_num
                FROM generated_contracts
                WHERE tenant_id = p_tenant_id AND contract_id = p_contract_id;
                
                BEGIN
                    INSERT INTO generated_contracts (
                        tenant_id, contract_id, template_id, generation_number,
                        contract_json, content_hash,
                        customer_name_snapshot, total_value_snapshot, services_count_snapshot,
                        generated_by, generation_reason
                    ) VALUES (
                        p_tenant_id, p_contract_id, v_template_id, v_gen_num,
                        v_json, v_hash,
                        v_customer_name, v_total_value, v_items_count,
                        p_user_id, p_reason
                    ) RETURNING id INTO v_gen_id;
                    
                    EXIT; -- Success, exit retry loop
                EXCEPTION
                    WHEN DUP_VAL_ON_INDEX THEN
                        v_retry_count := v_retry_count + 1;
                        IF v_retry_count >= gc_max_retries THEN
                            RAISE_APPLICATION_ERROR(-20010, 'Failed to generate unique generation_number after ' || gc_max_retries || ' attempts');
                        END IF;
                        -- Loop will retry with new MAX+1
                END;
            END LOOP;
        END;
        
        -- Note: No COMMIT here - caller manages transaction
        
        p_result := t_gen_result.ok(v_gen_id, v_hash);
        p_contract_json := v_json;
        
        log_action(
            p_tenant_id    => p_tenant_id,
            p_contract_id  => p_contract_id,
            p_generated_id => v_gen_id,
            p_action       => 'GENERATE',
            p_user_id      => p_user_id,
            p_ip_address   => p_ip_address,
            p_session_id   => p_session_id,
            p_status       => 'SUCCESS',
            p_error_code   => NULL
        );
        
    EXCEPTION
        WHEN OTHERS THEN
            -- Log the failure before rolling back (log_action uses AUTONOMOUS_TRANSACTION)
            log_action(
                p_tenant_id    => p_tenant_id,
                p_contract_id  => p_contract_id,
                p_generated_id => NULL,
                p_action       => 'GENERATE',
                p_user_id      => p_user_id,
                p_ip_address   => p_ip_address,
                p_session_id   => p_session_id,
                p_status       => 'FAILED',
                p_error_code   => gc_err_generation_failed || ': ' || SQLERRM
            );
            ROLLBACK;
            p_result := t_gen_result.err(gc_err_generation_failed, SQLERRM);
            p_contract_json := NULL;
    END;
    
    PROCEDURE get_generated(
        p_tenant_id    IN  VARCHAR2,
        p_generated_id IN  NUMBER,
        p_user_id      IN  VARCHAR2,
        p_json_data    OUT CLOB,
        p_content_hash OUT VARCHAR2,
        p_generated_at OUT TIMESTAMP,
        p_success      OUT NUMBER,
        p_error_code   OUT VARCHAR2
    ) IS
        v_contract_id NUMBER;
    BEGIN
        SELECT contract_json, content_hash, generated_at, contract_id
        INTO p_json_data, p_content_hash, p_generated_at, v_contract_id
        FROM generated_contracts
        WHERE id = p_generated_id AND tenant_id = p_tenant_id;
        
        p_success := 1;
        p_error_code := NULL;
        
        log_action(p_tenant_id, v_contract_id, p_generated_id, 'VIEW', p_user_id, NULL, NULL, 'SUCCESS', NULL);
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            p_json_data := NULL;
            p_content_hash := NULL;
            p_generated_at := NULL;
            p_success := 0;
            p_error_code := gc_err_contract_notfound;
    END;
    
    PROCEDURE get_latest_generated(
        p_tenant_id    IN  VARCHAR2,
        p_contract_id  IN  NUMBER,
        p_user_id      IN  VARCHAR2,
        p_json_data    OUT CLOB,
        p_content_hash OUT VARCHAR2,
        p_gen_id       OUT NUMBER,
        p_gen_at       OUT TIMESTAMP,
        p_success      OUT NUMBER,
        p_error_code   OUT VARCHAR2
    ) IS
    BEGIN
        SELECT contract_json, content_hash, id, generated_at
        INTO p_json_data, p_content_hash, p_gen_id, p_gen_at
        FROM generated_contracts
        WHERE tenant_id = p_tenant_id AND contract_id = p_contract_id
        ORDER BY generated_at DESC
        FETCH FIRST 1 ROW ONLY;
        
        p_success := 1;
        p_error_code := NULL;
        
        log_action(p_tenant_id, p_contract_id, p_gen_id, 'VIEW', p_user_id, NULL, NULL, 'SUCCESS', NULL);
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            p_json_data := NULL;
            p_content_hash := NULL;
            p_gen_id := NULL;
            p_gen_at := NULL;
            p_success := 0;
            p_error_code := gc_err_contract_notfound;
    END;
    
    PROCEDURE log_action(
        p_tenant_id    IN VARCHAR2,
        p_contract_id  IN NUMBER,
        p_generated_id IN NUMBER   DEFAULT NULL,
        p_action       IN VARCHAR2,
        p_user_id      IN VARCHAR2,
        p_ip_address   IN VARCHAR2 DEFAULT NULL,
        p_session_id   IN VARCHAR2 DEFAULT NULL,
        p_status       IN VARCHAR2 DEFAULT 'SUCCESS',
        p_error_code   IN VARCHAR2 DEFAULT NULL
    ) IS
        PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
        INSERT INTO contract_generation_log (
            tenant_id, contract_id, generated_id, action, action_status,
            performed_by, ip_address_hash, session_id_hash,
            error_code, error_category
        ) VALUES (
            p_tenant_id, p_contract_id, p_generated_id, p_action, p_status,
            p_user_id, 
            pkg_data_api.hash_sha256(p_ip_address), 
            pkg_data_api.hash_sha256(p_session_id),
            p_error_code,
            CASE 
                WHEN p_error_code LIKE '%UNAUTHORIZED%' OR p_error_code LIKE '%DENIED%' THEN 'AUTH'
                WHEN p_error_code LIKE '%NOT_FOUND%' OR p_error_code LIKE '%INVALID%' THEN 'VALIDATION'
                WHEN p_error_code IS NOT NULL THEN 'SYSTEM'
                ELSE NULL
            END
        );
        COMMIT;
    END;
    
    PROCEDURE init_default_template(
        p_tenant_id IN VARCHAR2,
        p_user_id   IN VARCHAR2
    ) IS
        v_exists NUMBER;
    BEGIN
        SELECT COUNT(*) INTO v_exists
        FROM contract_templates
        WHERE tenant_id = p_tenant_id AND is_default = 1;
        
        IF v_exists > 0 THEN
            RETURN;
        END IF;
        
        BEGIN
            INSERT INTO contract_templates (
                tenant_id, template_code, template_name, language, is_default, active,
                intro_text,
                payment_terms_text,
                general_terms,
                confidentiality,
                termination_clause,
                dispute_resolution,
                created_by
            ) VALUES (
                p_tenant_id, 'DEFAULT', 'Contrato Padrão de Prestação de Serviços', 'pt-BR', 1, 1,
                'Pelo presente instrumento particular, as partes abaixo qualificadas têm entre si justo e contratado o seguinte:',
                'O não pagamento nas datas avençadas implicará em multa de 2% (dois por cento) sobre o valor devido, acrescido de juros de mora de 1% (um por cento) ao mês, calculados pro rata die.',
                'a) O CONTRATANTE declara ter ciência de todas as condições estabelecidas neste contrato.
b) Qualquer alteração das condições aqui pactuadas somente terá validade se feita por escrito e assinada por ambas as partes.
c) As partes elegem o presente contrato como título executivo extrajudicial, nos termos do Art. 784, III do Código de Processo Civil.',
                'As partes se comprometem a manter sigilo sobre todas as informações confidenciais a que tiverem acesso em razão do presente contrato. Esta obrigação permanecerá em vigor por 5 (cinco) anos após o término do contrato. O descumprimento ensejará penalidades previstas na LGPD (Lei nº 13.709/2018).',
                'O presente contrato poderá ser rescindido:
a) Por mútuo acordo, com aviso prévio de 30 dias;
b) Por descumprimento contratual, após notificação com prazo de 15 dias para regularização;
c) Por força maior ou caso fortuito;
d) Unilateralmente, com aviso de 60 dias e multa de 20% do valor remanescente.',
                'As partes elegem o Foro da Comarca onde está situada a sede da CONTRATADA para dirimir quaisquer dúvidas ou litígios.',
                p_user_id
            );
            
            -- Note: No COMMIT here - caller manages transaction
        EXCEPTION
            WHEN DUP_VAL_ON_INDEX THEN
                -- Another session already inserted the default template (race condition)
                -- This is fine - the template exists now, so just return
                RETURN;
        END;
    END;
    
    -- Verify integrity of generated contract
    -- Returns: 1 = hash matches (valid)
    --          0 = hash mismatch (tampered)
    --         -2 = record not found
    FUNCTION verify_integrity(p_generated_id IN NUMBER) RETURN NUMBER IS
        v_stored_hash  VARCHAR2(64);
        v_content      CLOB;
    BEGIN
        SELECT content_hash, contract_json
        INTO v_stored_hash, v_content
        FROM generated_contracts
        WHERE id = p_generated_id;
        
        IF v_stored_hash = pkg_data_api.hash_clob_sha256(v_content) THEN
            RETURN 1;  -- Valid: hash matches
        ELSE
            RETURN 0;  -- Invalid: hash mismatch (content tampered)
        END IF;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN -2; -- Not found: record does not exist;
    END;
    
    PROCEDURE get_stats(
        p_tenant_id   IN  VARCHAR2,
        p_total       OUT NUMBER,
        p_today       OUT NUMBER,
        p_month       OUT NUMBER,
        p_unique      OUT NUMBER
    ) IS
    BEGIN
        SELECT 
            COUNT(*),
            SUM(CASE WHEN TRUNC(generated_at) = TRUNC(SYSDATE) THEN 1 ELSE 0 END),
            SUM(CASE WHEN generated_at >= TRUNC(SYSDATE, 'MM') THEN 1 ELSE 0 END),
            COUNT(DISTINCT contract_id)
        INTO p_total, p_today, p_month, p_unique
        FROM generated_contracts
        WHERE tenant_id = p_tenant_id;
    END;

END pkg_contract_generation;
/

-- Trigger for template versioning
CREATE OR REPLACE TRIGGER trg_contract_templates_updated
BEFORE UPDATE ON contract_templates
FOR EACH ROW
BEGIN
    :NEW.updated_at := CURRENT_TIMESTAMP;
    :NEW.version := :OLD.version + 1;
END;
/
